%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,croatian]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{0}



\title{RPPIOT prakticni materijali}
\date{stu 29, 2021}
\release{}
\author{Zlatan Sicanica}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
Ovaj dokument sadrzi objasnjenja koda napisanog u repozitorijima s primjerima.
Svaki repozitorij odgovara zadatcima/radionicama s predavanja, a ovdje su oni
detaljnije objasnjeni, skupa s postupkom rjesavanja.


\chapter{Arhitektura}
\label{\detokenize{01-architecture/index:arhitektura}}\label{\detokenize{01-architecture/index::doc}}
\sphinxAtStartPar
Ovaj primjer oslanja se na drugo predavanje o arhitekturama industrijskih IoT
sustava.


\section{Zadatak}
\label{\detokenize{01-architecture/index:zadatak}}
\sphinxAtStartPar
Zamisljena je situacija da imamo sljedeci dio elektricne sheme:

\noindent\sphinxincludegraphics{{ammeters}.png}

\sphinxAtStartPar
Ampermetri su industrijski uredaji koji svoja stanja notificiraju pomocu IEC104
protokola. Zadatak je citati te podatke, ispisati ih na konzolu i u taj ispis
ukljuciti i novu vrijednost, koja bi predstavljala struju I4, zbroj ostale tri
jakosti struja.

\sphinxAtStartPar
Implementacija zadatka moze se preuzeti iz \sphinxhref{https://github.com/rppiot2021/01-architecture}{repozitorija}. Strukturiran je tako da se u
paketu \sphinxcode{\sphinxupquote{simulator}} nalazi implementacija simulatora ampermetara. Simulaciju
je potrebno pokrenuti prema uputama iz repozitorija i ispis bi trebao izgledati
ovako:

\noindent\sphinxincludegraphics{{simulator}.png}

\sphinxAtStartPar
U paketu \sphinxcode{\sphinxupquote{solution}} nalazi se rjesenje zadataka do kojeg smo dosli na
predavanju. Ono moze posluziti kao referenca, a u nastavku cemo detaljnije
objasniti poduzete korake za dolazak do njega.


\section{Rjesenje}
\label{\detokenize{01-architecture/index:rjesenje}}

\subsection{Priprema}
\label{\detokenize{01-architecture/index:priprema}}
\sphinxAtStartPar
Prvi korak u dolasku do rjesenja je ostvarivanje komunikacije sa simulatorom.
Prema njegovim uputama, on svoje podatke posluzuje na adresi
\sphinxcode{\sphinxupquote{127.0.0.1:9999}}, koristeci protokol IEC104. IEC104 je industrijski protokol
koji se cesto koristi u podrucju elektroenergetike, a ovdje je iskoristen jer
ima relativno jednostavno sucelje.

\sphinxAtStartPar
Ako znamo s kakvim komunikacijskim protokolom uredaj radi, iduci korak za
ostvarivanje komunikacije je nalazak odgovarajuce upravljacke biblioteke koja
implementira protokol IEC104. Takva biblioteka pruzala bi svojim korisnicima
funkcije i klase za otvaranje konekcije s uredajem, slanje i primanje podataka
s te konekcije. Jedna implementacija upravljacke biblioteke za IEC104 je
biblioteka koju smo koristili na predavanju, \sphinxhref{https://hat-drivers.hat-open.com}{hat\sphinxhyphen{}drivers} iz \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}open}} projekta. Ova biblioteka
sadrzi i druge protokole, no u ovom primjeru se samo fokusiramo na \sphinxhref{https://hat-drivers.hat-open.com/iec104.html}{IEC104}.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{asyncio}}}
\label{\detokenize{01-architecture/index:asyncio}}
\sphinxAtStartPar
Gledanjem dokumentacije biblioteke, vidimo da je prva funkcija koju je potrebno
koristiti \sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/iec104/index.html\#hat.drivers.iec104.connect}{hat.drivers.iec104.connect},
koja otvara konekciju s uredajem. Iz potpisa funkcije mozemo vidjeti nove
potrebe:
\begin{itemize}
\item {} 
\sphinxAtStartPar
funkcija je \sphinxcode{\sphinxupquote{async}}, odnosno, namjenjena je pokretanju kroz Pythonovu
\sphinxcode{\sphinxupquote{asyncio}} infrastrukturu

\item {} 
\sphinxAtStartPar
adresa na kojoj simulator posluzuje podatke je jedini obvezni argument

\end{itemize}

\sphinxAtStartPar
Adresa je vec navedena u samom zadatku, a asyncio pokrecemo s ovakvim kodom:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} standardna dobra praksa za definiranje ulazne tocke}
\PYG{c+c1}{\PYGZsh{} u Python program}
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Sad u \sphinxcode{\sphinxupquote{async\_main}} funkciji mozemo koristiti \sphinxcode{\sphinxupquote{await}} pozive za pokretanje
konkurentnih metoda (vise o koristima \sphinxcode{\sphinxupquote{asyncio}}\sphinxhyphen{}a mozete vidjeti u sluzbenoj
dokumentaciji). Prakticno, to nam omogucava da koristimo \sphinxcode{\sphinxupquote{iec104.connect}}
funkciju.


\subsection{„Grubo” rjesenje}
\label{\detokenize{01-architecture/index:grubo-rjesenje}}
\sphinxAtStartPar
U ovom dijelu razviti cemo rjesenje koje prakticno rjesava problem, ali ne
uzima u obzir dobre organizacijske prakse kojih se drzimo ako odaberemo neku
arhitekturu. Umjesto postojanja tri nezavisne, specijalizirane komponente,
cijeli IoT sustav bit ce implementiran u jednoj \sphinxcode{\sphinxupquote{while}} petlji.

\sphinxAtStartPar
Prvi korak je otvaranje veze na ampermetre, moguce ga je napraviti pozivom
\sphinxcode{\sphinxupquote{await iec104.connect(iec104.Address(\textquotesingle{}127.0.0.1\textquotesingle{}, 9999))}}. Ovdje je adresa
predana kroz strukturu podataka specificiranu od strane \sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/iec104/connection.html\#hat.drivers.iec104.connection.Address}{drivera}.

\sphinxAtStartPar
Nakon sto smo se spojili na ampermetar, zelimo ocitavati podatke s njega.
\sphinxcode{\sphinxupquote{connect}} funkcija nam je vratila instancu klase
\sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/iec104/connection.html\#hat.drivers.iec104.connection.Connection}{hat.drivers.iec104.Connection}.
Gledanjem dokumentacije te klase, vidimo da to mozemo pomocu metode
\sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/iec104/connection.html\#hat.drivers.iec104.connection.Connection.receive}{hat.drivers.iec104.Connection.receive}.
Ova metoda ne prima nikakve argumente i vraca listu instanci klase
\sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/iec104/common.html\#hat.drivers.iec104.common.Data}{hat.drivers.iec104.Data}.
Ako dodamo ispis vrijednosti koje su primljene kao argument, nase rjesenje
trenutno izgleda ovako:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{drivers} \PYG{k+kn}{import} \PYG{n}{iec104}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{connection} \PYG{o}{=} \PYG{k}{await} \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}
        \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{127.0.0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{9999}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{n}{data} \PYG{o}{=} \PYG{k}{await} \PYG{n}{connection}\PYG{o}{.}\PYG{n}{receive}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} standardna dobra praksa za definiranje ulazne tocke}
\PYG{c+c1}{\PYGZsh{} u Python program}
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
A ispis, ako ga pokrenemo paralelno uz simulator izgleda ovako:

\noindent\sphinxincludegraphics{{output1}.png}

\sphinxAtStartPar
Vidimo kako ispis izgleda dosta neuredno, razlog tome je cinjenica da paketi
IEC104 protokola sadrze dosta dodatnih informacija, poput kvalitete podatka,
vremena kad je ocitan, i sl., koje nam trenutno nisu potrebne i mozemo ih
ignorirati. Konkretno, citanjem \sphinxhref{https://github.com/rppiot2021/01-architecture}{opisa zadatka}, vidimo da nam je jedino
zanimljivo polje, osim \sphinxcode{\sphinxupquote{value}} u kojem je zapisana vrijednost ocitanja,
\sphinxcode{\sphinxupquote{asdu\_address}} jer njega koristimo kao identifikator ampermetra (razlikovanje
I1, I2 i I3). Jos jedan suptilni detalj je cinjenica da u \sphinxcode{\sphinxupquote{value}} nije
zapisan direktno broj, vec, kako IEC104 podrzava slanje razlicitih tipova
podataka preko istog sucelja, zapisana je instanca klase
\sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/iec104/common.html\#hat.drivers.iec104.common.FloatingValue}{hat.drivers.iec104.FloatingValue}.
To oznacava da je preko protokola primljen realni broj i da mu se moze
pristupiti preko varijable \sphinxcode{\sphinxupquote{hat.drivers.iec104.FloatingValue.value}}. Dakle,
do identifikatora ampermetra dolazimo preko \sphinxcode{\sphinxupquote{data{[}0{]}.asdu\_address}}, a do
iznosa ocitanog na ampermetru preko \sphinxcode{\sphinxupquote{data{[}0{]}.value.value}}. \sphinxcode{\sphinxupquote{{[}0{]}}} je
potreban jer je preko \sphinxcode{\sphinxupquote{receive}} metode moguce primiti vise od jednog podatka,
no zadatak je postavljen tako da se uvijek notificira jedna promjena pa je
ovakav hack prihvatljiv.

\sphinxAtStartPar
Dodatni zahtjev je kontinuirano izracunavanje vrijednosti I4, zbroja ostale tri
struje, i njegov kontinuirani ispis na konzoli. Radi jednostavnosti provjere,
ispisivati cemo stanje sve tri struje uz I4. Uz to, radi urednosti ispisa,
dodatno cemo zaokruziti sve vrijednosti na dvije decimale. Stanja cemo cuvati u
dictionary\sphinxhyphen{}ju gdje su nam kljucevi imena struja, a vrijednosti njihovi iznosi.
Mozemo ga izvesti ovako:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{drivers} \PYG{k+kn}{import} \PYG{n}{iec104}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{connection} \PYG{o}{=} \PYG{k}{await} \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}
        \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{127.0.0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{9999}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{state} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{n}{data} \PYG{o}{=} \PYG{k}{await} \PYG{n}{connection}\PYG{o}{.}\PYG{n}{receive}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{meter} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{[}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{asdu\PYGZus{}address}\PYG{p}{]}
        \PYG{n}{state}\PYG{p}{[}\PYG{n}{meter}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n}{state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYG{n}{state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYG{n}{state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{state}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} standardna dobra praksa za definiranje ulazne tocke}
\PYG{c+c1}{\PYGZsh{} u Python program}
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Ispis ce sada izgledati ovako:

\noindent\sphinxincludegraphics{{output2}.png}

\sphinxAtStartPar
Ovime smo zadovoljili minimalne potrebe zadatka, no ne mozemo tvrditi da je
rjesenje dugorocno odrzivo. Ako se potrebe promijene, npr. zelimo komunicirati
s drugim protokolom, potrebna su dodatna mjerenja, nove vrste izracuna ili
drugaciji nacin vizualizacije, takve promjene je tesko implementirati u ovakvo
rjesenje. Zbog toga si mozemo pomoci tako da rjesenje implementiramo pomocu
specijaliziranih komponenti.


\subsection{Rjesenje bazirano na predlozenoj arhitekturi}
\label{\detokenize{01-architecture/index:rjesenje-bazirano-na-predlozenoj-arhitekturi}}
\sphinxAtStartPar
U predavanju je predstavljena okvirna ideja kako generalno izgledaju
arhitekture IIoT sustava. Obicno nastanu tri glavne komponente, jedna za
komunikaciju s fizickim uredajima, druga za obradu podataka koji se prime s
njih i treca za prezentaciju podataka korisniku. Ovakvu vrstu specijalizacije
cemo uvesti i u nase rjesenje.

\sphinxAtStartPar
Klase su najjednostavniji nacin kako mozemo definirati odvojene komponente i
implementirati njihovu specijaliziranu logiku. Prva komponenta koja se namece
je komponenta za komunikaciju s uredajima. Shodno tome, definiramo klasu
\sphinxcode{\sphinxupquote{Communication}} koja sadrzi logiku za ostvarivanje veze s uredajem, primanje
podataka s njega i njihovo daljnje slanje u modul za obradu podataka. Zasad
nemamo komponentu za obradu podataka, tako da cemo cijelu logiku obrade i
prezentacije podataka kopirati u funkciju koja obavlja primanje podataka. Tako
dolazimo do sljedece verzije rjesenja:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{drivers} \PYG{k+kn}{import} \PYG{n}{iec104}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{class} \PYG{n+nc}{Communication}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}connection} \PYG{o}{=} \PYG{k+kc}{None}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{connect}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}connection} \PYG{o}{=} \PYG{k}{await} \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}
            \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{127.0.0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{9999}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{receive\PYGZus{}loop}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{state} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
        \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
            \PYG{n}{data} \PYG{o}{=} \PYG{k}{await} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}connection}\PYG{o}{.}\PYG{n}{receive}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{meter} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                     \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                     \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{[}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{asdu\PYGZus{}address}\PYG{p}{]}
            \PYG{n}{state}\PYG{p}{[}\PYG{n}{meter}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{n}{state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                                \PYG{o}{+} \PYG{n}{state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                                \PYG{o}{+} \PYG{n}{state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{state}\PYG{p}{)}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{communication} \PYG{o}{=} \PYG{n}{Communication}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{await} \PYG{n}{communication}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{await} \PYG{n}{communication}\PYG{o}{.}\PYG{n}{receive\PYGZus{}loop}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} standardna dobra praksa za definiranje ulazne tocke}
\PYG{c+c1}{\PYGZsh{} u Python program}
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Ispis rjesenja izgleda isto kao i kod ranije verzije rjesenja. Razlog tome je
jednostavan, logika je ostala ista, samo je cijela petlja prebacena u
\sphinxcode{\sphinxupquote{Communication}} klasu. Sad cemo ju dodatno razbiti tako sto cemo dodati novu
komponentu za obradu podataka, implementiranu u klasi \sphinxcode{\sphinxupquote{Processing}}. Ona ima
glavnu metodu \sphinxcode{\sphinxupquote{process}}, koja sadrzi logiku za izracun struje I4 i ispis
podataka (zasad, dok ne dodamo komponentu za vizualizaciju). Jos jedan dodatak
je da sad \sphinxcode{\sphinxupquote{Communication}} komponenta treba imati referencu na \sphinxcode{\sphinxupquote{Processing}}
jer je to najjednostavniji nacin da ju „obavijesti” o tome da je primila novo
ocitanje. Alternativa bi bila da komuniciraju na neki drugi nacin, npr. preko
\sphinxhref{https://docs.python.org/3/library/asyncio-queue.html}{asyncio.Queue}, zapisa
i citanja datoteke, preko socketa, … Tako dolazimo do nove verzije naseg
rjesenja:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{drivers} \PYG{k+kn}{import} \PYG{n}{iec104}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{class} \PYG{n+nc}{Communication}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{processing}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}connection} \PYG{o}{=} \PYG{k+kc}{None}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}processing} \PYG{o}{=} \PYG{n}{processing}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{connect}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}connection} \PYG{o}{=} \PYG{k}{await} \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}
            \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{127.0.0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{9999}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{receive\PYGZus{}loop}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
            \PYG{n}{data} \PYG{o}{=} \PYG{k}{await} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}connection}\PYG{o}{.}\PYG{n}{receive}\PYG{p}{(}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}processing}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{Processing}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}

    \PYG{k}{def} \PYG{n+nf}{process}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{iec104\PYGZus{}data}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{meter} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                 \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                 \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{[}\PYG{n}{iec104\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{asdu\PYGZus{}address}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{n}{meter}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{iec104\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                                  \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                                  \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{)}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{processing} \PYG{o}{=} \PYG{n}{Processing}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{communication} \PYG{o}{=} \PYG{n}{Communication}\PYG{p}{(}\PYG{n}{processing}\PYG{p}{)}
    \PYG{k}{await} \PYG{n}{communication}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{await} \PYG{n}{communication}\PYG{o}{.}\PYG{n}{receive\PYGZus{}loop}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} standardna dobra praksa za definiranje ulazne tocke}
\PYG{c+c1}{\PYGZsh{} u Python program}
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Konacno, ako zelimo imati arhitekturu opisanu u predavanju, fali nam jos i
komponenta za vizualizaciju. Trenutno se cijelo stanje aplikacije ispisuje
diraktno na konzolu, htjeli bismo tu logiku izdvojiti u zasebnu komponentu i
mozda izbaciti neki stiliziraniji ispis od Pythonove pretvorbe dictionary\sphinxhyphen{}ja u
string. Stvaramo novu klasu, \sphinxcode{\sphinxupquote{Visual}}, koja ima metodu \sphinxcode{\sphinxupquote{render}}. Ona prima
stanje aplikacije u formatu koji propisuje \sphinxcode{\sphinxupquote{Processing}} klasa, i ispisuje
vrijednosti na konzolu. Zaokruzivanje mozemo takoder prebaciti u ovu klasu,
posto je ono u ovom slucaju iskljucivo vizualna prilagodba podatka. Slicno kao
i kod povezivanja klasa za komunikaciju i obradu podataka, komponenta za obradu
podataka ima referencu na komponentu za vizualizaciju, kako bi joj mogla
proslijediti nove verzije svog stanja. Alternative takvom obliku komunikacije
iste su kao i kod veze komunikacija\sphinxhyphen{}obrada. Tako dolazimo do ove verzije
rjesenja:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{drivers} \PYG{k+kn}{import} \PYG{n}{iec104}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{class} \PYG{n+nc}{Communication}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{processing}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}connection} \PYG{o}{=} \PYG{k+kc}{None}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}processing} \PYG{o}{=} \PYG{n}{processing}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{connect}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}connection} \PYG{o}{=} \PYG{k}{await} \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}
            \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{127.0.0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{9999}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{receive\PYGZus{}loop}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
            \PYG{n}{data} \PYG{o}{=} \PYG{k}{await} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}connection}\PYG{o}{.}\PYG{n}{receive}\PYG{p}{(}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}processing}\PYG{o}{.}\PYG{n}{process}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{Processing}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{visual}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}visual} \PYG{o}{=} \PYG{n}{visual}

    \PYG{k}{def} \PYG{n+nf}{process}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{iec104\PYGZus{}data}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{meter} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                 \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                 \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{[}\PYG{n}{iec104\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{asdu\PYGZus{}address}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{n}{meter}\PYG{p}{]} \PYG{o}{=} \PYG{n}{iec104\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}\PYG{o}{.}\PYG{n}{value}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                             \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                             \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}visual}\PYG{o}{.}\PYG{n}{render}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{Visual}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{render}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{state}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{key}\PYG{p}{,} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{state}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{value}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{visual} \PYG{o}{=} \PYG{n}{Visual}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{processing} \PYG{o}{=} \PYG{n}{Processing}\PYG{p}{(}\PYG{n}{visual}\PYG{p}{)}
    \PYG{n}{communication} \PYG{o}{=} \PYG{n}{Communication}\PYG{p}{(}\PYG{n}{processing}\PYG{p}{)}
    \PYG{k}{await} \PYG{n}{communication}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{await} \PYG{n}{communication}\PYG{o}{.}\PYG{n}{receive\PYGZus{}loop}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} standardna dobra praksa za definiranje ulazne tocke}
\PYG{c+c1}{\PYGZsh{} u Python program}
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Ona sad ima i drugaciji ispis, koji izgleda ovako:

\noindent\sphinxincludegraphics{{output3}.png}

\sphinxAtStartPar
Ovime smo implementirali rjesenje problema koje je ujedno i arhitekturalno
smisleno, odnosno, moguce ga je prosirivati s dolaskom novih zahtjeva. Logicke
cjeline su medusobno odvojene i relativno jednostavno ih mozemo prilagodavati
po potrebi. Jedna ocita slabost ovako postavljenog sustava je cinjenica da
pojedine komponente moraju biti upoznate s nacinom kako funkcioniraju ostale
komponente u sustavu. Tako npr, \sphinxcode{\sphinxupquote{Communication}} klasa mora znati za
\sphinxcode{\sphinxupquote{Processing}} i mora znati sto mu salje u \sphinxcode{\sphinxupquote{process}} metodu. Ako se ikad
dogodi da nam takvo sucelje vise ne bude dovoljno dobro, potrebno je raditi
ekstenzivnije modifikacije (mijenjati i \sphinxcode{\sphinxupquote{Processing}} i \sphinxcode{\sphinxupquote{Communication}}
komponente). I dodatak novih uredaja/komunikacijskih protokola s kojima se radi
i dalje zahtjeva reorganizaciju \sphinxcode{\sphinxupquote{Communication}} dijela. Zbog svega ovoga,
pribjegavamo koristenju gotovih rjesenja koja se brinu o infrastrukturi oko
dijelova implementacije koji su specificni za konkretni problem koji se
rjesava. Konkretne primjere ovoga vidjet cemo kad krenemo raditi s
infrastrukturnim komponentama koje su implementeirane u sklopu \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}open}}
projekta.


\chapter{Modbus konzolna aplikacija}
\label{\detokenize{02-modbus-console/index:modbus-konzolna-aplikacija}}\label{\detokenize{02-modbus-console/index::doc}}
\sphinxAtStartPar
Ovo poglavlje pokriva prvi dio radionice s 4. predavanja, spajanje na Modbus
uredaj preko konzolne aplikacije i ispis ocitane vrijednosti na izlaz. Rjesenje
je objavljeno na \sphinxhref{https://github.com/rppiot2021/02-modbus-console}{repozitoriju s predavanja}, a ovaj dio opisuje korake
potrebne za dolazak do njega.


\section{Zadatak}
\label{\detokenize{02-modbus-console/index:zadatak}}
\sphinxAtStartPar
Na adresi 161.53.17.239:8502 preko Modbus TCP protokola posluzuju se podatci o
temperaturi s termometra. Specifikacija uredaja je dostupna na \sphinxhref{https://download.inveo.com.pl/manual/nano\_t\_poe/user\_manual\_en.pdf}{ovoj adresi}.
Potrebno je napraviti konzolnu aplikaciju koja ce se spojiti na ovaj uredaj i
ispisivati ocitanja temperature. Nije potrebno pretjerano se zamarati s
trazenjem optimalne arhitekture, jer ce se kasnije razvijati rjesenje bazirano
na tehnologijama iz \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}open}} projekta, koje pokrivaju te probleme.


\section{Rjesenje}
\label{\detokenize{02-modbus-console/index:rjesenje}}
\sphinxAtStartPar
Kao i prosli put, prvi korak je proucavanje komunikacijskog sucelja uredaja s
kojim radimo. Gledanjem \sphinxtitleref{specifikacije
\textless{}https://download.inveo.com.pl/manual/nano\_t\_poe/user\_manual\_en.pdf\textgreater{}}, vidimo
da podatcima o temperaturi mozemo pristupiti na vise nacina, no mi se u sklopu
zadatka fokusiramo na Modbus, cije sucelje je opisano u poglavlju 7.7. U njemu
se nalazi nekoliko tablica na temelju kojih mozemo pristupati podatcima,
konfigurirati uredaj i sl. Tablice imaju stupce \sphinxtitleref{Address}, \sphinxtitleref{Name}, \sphinxtitleref{R/W} i
\sphinxtitleref{Description}. \sphinxtitleref{Address} nam je najzanimljiviji podatak, njega mozemo
intepretirati kao identifikator ocitanja. Po Modbus protokolu, ocitanja se
modeliraju kao sekvencijalna memorija i klijenti koji se spajaju na Modbus
uredaje, pristupaju podatcima tako da salju zahtjeve za citanje odredene
adrese. Sto se tice ostalih stupaca, po \sphinxtitleref{Description} mozemo vidjeti semantiku
svake adrese. Vidimo da adresa 4004 ima informaciju o temperaturi pomnozenu s
10. To je adresa kojoj cemo pristupati preko nase konzolne aplikacije.

\sphinxAtStartPar
Drugi korak je nabavljanje komunikacijskog drivera za Modbus. To opet mozemo
koristiti \sphinxhref{https://hat-drivers.hat-open.com}{hat\sphinxhyphen{}drivers} paket, ovaj put
\sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/modbus/index.html}{Modbus implementaciju}.
Vidimo kako ona ima razne funkcije za kreiranje konekcije, na temelju tipa
konekcije koju zelimo otvoriti cemo odabrati jednu od \sphinxcode{\sphinxupquote{create\_...}} funkcija.
S obzirom da se uredaj ponasa kao slave, to znaci da ce se nasa konzolna
aplikacija ponasati kao master. Dodatno, komuniciramo preko TCP\sphinxhyphen{}a, ne preko
serial porta, tako da cemo koristiti funkciju
\sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/modbus/index.html\#hat.drivers.modbus.create\_tcp\_master}{hat.drivers.modbus.create\_tcp\_master}.
Ova funkcija prima dva obvezna argumenta, \sphinxcode{\sphinxupquote{modbus\_type}} i \sphinxcode{\sphinxupquote{address}}.
\sphinxcode{\sphinxupquote{modbus\_type}} je tip Modbus uredaja s kojim se radi, to je enumeracija
definirana od strane biblioteke \sphinxtitleref{hat.drivers.modbus.ModbusType
\textless{}https://hat\sphinxhyphen{}drivers.hat\sphinxhyphen{}open.com/py\_api/hat/drivers/modbus/common.html\#hat.drivers.modbus.common.ModbusType\textgreater{}}.
Radimo s TCP\sphinxhyphen{}om, tako da je \sphinxcode{\sphinxupquote{ModbusType.TCP}} ispravan tip. \sphinxcode{\sphinxupquote{address}} je
struktura podataka koja predstavlja TCP adresu, definirana na
\sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/tcp.html\#hat.drivers.tcp.Address}{hat.drivers.tcp.Address}.
Tu unosimo IP adresu i port na kojoj termometar posluzuje podatke. Uz sve ovo,
vidimo da je \sphinxcode{\sphinxupquote{create\_tcp\_master}} funkcija \sphinxcode{\sphinxupquote{async}} te da ju je potrebno
pokretati kroz asyncio infrastrukturu.

\sphinxAtStartPar
Temeljem svega spomenutog, dolazimo do prve verzije rjesenja, gdje se samo
spajamo na termometar:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{drivers} \PYG{k+kn}{import} \PYG{n}{modbus}\PYG{p}{,} \PYG{n}{tcp}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{master} \PYG{o}{=} \PYG{k}{await} \PYG{n}{modbus}\PYG{o}{.}\PYG{n}{create\PYGZus{}tcp\PYGZus{}master}\PYG{p}{(}
        \PYG{n}{modbus}\PYG{o}{.}\PYG{n}{ModbusType}\PYG{o}{.}\PYG{n}{TCP}\PYG{p}{,}
        \PYG{n}{tcp}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{127.0.0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{9999}\PYG{p}{)}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{create\_tcp\_master}} vraca objekt tipa \sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/modbus/master.html\#hat.drivers.modbus.master.Master}{hat.drivers.modbus.Master}.
Gledanjem njegove konfiguracije, vidimo da on ima funkciju \sphinxhref{https://hat-drivers.hat-open.com/py\_api/hat/drivers/modbus/master.html\#hat.drivers.modbus.master.Master}{read}.
Ona ima obvezne argumente \sphinxcode{\sphinxupquote{device\_id}}, \sphinxcode{\sphinxupquote{data\_type}} i \sphinxcode{\sphinxupquote{start\_address}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{device\_id}} oslanja se na cinjenicu da Modbus protokol moze biti realiziran
kao \sphinxhref{https://en.wikipedia.org/wiki/Multidrop\_bus}{multidrop}. To znaci da na
jednu konekciju moze biti spojeno vise stvarnih uredaja i argumentima poput
\sphinxcode{\sphinxupquote{device\_id}}\sphinxhyphen{}a se specificira kojem uredaju se treba proslijediti taj zahtjev.
U nasem konkretnom slucaju, nemamo vise uredaja u multidropu, pa je
prihvatljiva vrijednost za identifikator 1.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_type}} referencira tip podatka koje Modbus moze posluzivati. Protokol
podrzava tipove poput coil i holding register (nazivi iz povjesnih razloga kad
se radilo s fizickim registrima i zavojnicama). Po tablici iz specifikacije
uredaja, vidimo da je temperatura zapisana u holidng register\sphinxhyphen{}u, tako da
koristimo enumeraciju \sphinxcode{\sphinxupquote{hat.drivers.modbus.DataType.HOLDING\_REGISTER}} kao
\sphinxcode{\sphinxupquote{data\_type}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{start\_address}} je adresa na kojoj je podatak posluzen. Po tablici u
dokumentaciji to se posluzuje na adresi 4004, tako da je to vrijednost.
Isprobavanjem rjesenja, videno je da je ova informacija zapravo zapisana na
adresi 4003, sto je vjerojatno zbog pocetnog indeksa, dokumentacija krece od 1,
dok Modbus driver pretpostavlja start od 0. Dakle, \sphinxcode{\sphinxupquote{start\_address}} je 4003.

\sphinxAtStartPar
Recimo da zelimo kontinuirano slati upite za ocitanjem na uredaj svakih 5
sekundi. Onda bi nam rjesenje izgledalo ovako:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{drivers} \PYG{k+kn}{import} \PYG{n}{modbus}\PYG{p}{,} \PYG{n}{tcp}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{master} \PYG{o}{=} \PYG{k}{await} \PYG{n}{modbus}\PYG{o}{.}\PYG{n}{create\PYGZus{}tcp\PYGZus{}master}\PYG{p}{(}
        \PYG{n}{modbus}\PYG{o}{.}\PYG{n}{ModbusType}\PYG{o}{.}\PYG{n}{TCP}\PYG{p}{,}
        \PYG{n}{tcp}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{161.53.17.239}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{8502}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{n}{data} \PYG{o}{=} \PYG{k}{await} \PYG{n}{master}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}
            \PYG{n}{device\PYGZus{}id}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}
            \PYG{n}{data\PYGZus{}type}\PYG{o}{=}\PYG{n}{modbus}\PYG{o}{.}\PYG{n}{DataType}\PYG{o}{.}\PYG{n}{HOLDING\PYGZus{}REGISTER}\PYG{p}{,}
            \PYG{n}{start\PYGZus{}address}\PYG{o}{=}\PYG{l+m+mi}{4003}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
        \PYG{k}{await} \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Ovime na konzolni ispis dobivamo temperaturu pomnozenu s 10. Rjesenje bi se
dalo raspisivati detaljnije, kao u prvom zadatku, uvoditi konkretnu arhitekturu
i sl., no ovdje je ideja nastaviti s Hat tehnologijama. Iduci zadatak opisuje
kako izvesti istu stvar, koristenjem Hatove infrastrukture.


\chapter{Hat}
\label{\detokenize{hat/index:hat}}\label{\detokenize{hat/index::doc}}
\sphinxAtStartPar
Prije nastavka rjesavanja problema s termometrom, dati cemo uvod u glavne
aspekte komponenti Hat projekta, jer cemo se oslanjati na njih za rjesenje. Ovo
poglavlje je zamisljeno kao prirucnik tim komponentama, i mozete mu se vratiti
kad god zapnete.

\sphinxAtStartPar
U drugom predavanju upoznali smo se s glavnim industrijskim praksama vezanim uz
organizaciju koda, i ovdje cemo ih dosta referencirati. Vidjeli smo kako
industrijski IoT sustavi obicno imaju ovakvu generalnu arhitekturu:

\sphinxAtStartPar
Takoder smo spominjali koristi izvodenja takve arhitekture pomocu event\sphinxhyphen{}driven
sustavi. Implementacija takvih sustava moze se vizualizirati sljedecim
dijagramom:

\sphinxAtStartPar
Vidimo kako postoje razliciti aktori u sustavu izmedu kojih se nalazi \sphinxtitleref{Event
bus}, sabirnica dogadaja. Ideja je da kreatori notificiraju sabirnicu dogadaja
o novonastalim promjenama, a onda sabirnica proslijedi te informacije svim
zainteresiranim konzumentima. Dogadaj se obicno modelira kao neka struktura
koja sadrzi informaciju o semantickom znacenju dogadaja (npr. detektirana je
promjena temperature) i konkretne podatke specificne za promjenu (npr. iznos
temperature), a mogu biti i popraceni razlicitim vremenskim oznakama (kad je
napravljeno ocitanje), dodatnim zastavicama itd.

\sphinxAtStartPar
U kontekstu industrijskih IoT sustava, generalna arhitektura predstavljena
ranije, moze se izvesti kroz event\sphinxhyphen{}driven sustav. Jedan nacin kako bi ona mogla
biti izvedena je sljedeci:

\sphinxAtStartPar
Vidimo da su glavne komponente u principu ostale iste, glavna razlika je da su
one sad povezane preko sabirnice dogadaja, dok prije nije bilo egzaktno
specificirano kako komuniciraju. Komponente iz hat\sphinxhyphen{}open projekta imaju ovakvu
arhitekturu. Glavne komponente kojima cemo se baviti u nasim zadatcima su event
server (event bus + business logic), gateway (communication) i GUI server
(human\sphinxhyphen{}machine interface). Uz njih, projekt iz kojeg cemo razvijati nase
rjesenje konfigurira i druge komponente, ali njima cemo pristupati samo iz
prespektive korisnika, a manje raditi neki konkretan razvoj vezan uz njih.


\section{hat\sphinxhyphen{}event (event bus)}
\label{\detokenize{hat/event_bus:hat-event-event-bus}}\label{\detokenize{hat/event_bus::doc}}
\sphinxAtStartPar
Prva komponenta koju gledamo je event server. Ona zapravo ima dvostranu ulogu,
prva je da se ponasa kao sabirnica dogadaja, a druga da sadrzi specijalizirane
module za poslovnu logiku. U ovom dijelu fokusiramo se na prvi aspekt,
komunikacijsku sabirnicu. Trenutno cemo napraviti malu digresiju od primjera s
termometrom, da pokazemo neke generalne ideje oko rada s event serverom, koje
su primjenjive u cijelom sustavu.

\sphinxAtStartPar
Event server se pokrece pozivom naredbe \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}event}}. Ta naredba prima
komandnolinijski argument \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}conf}} kojim joj se predaje putanja do
konfiguracijske datoteke. Ta datoteka je u JSON ili YAML formatu i ima
strukturu propisanu \sphinxhref{https://github.com/hat-open/hat-event/blob/master/schemas\_json/main.yaml}{JSON shemom}.
Minimalna konfiguracija mogla bi biti:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nn}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+nt}{backend\PYGZus{}engine}\PYG{p}{:}
    \PYG{n+nt}{backend}\PYG{p}{:}
        \PYG{n+nt}{module}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{hat.event.server.backends.dummy}
    \PYG{n+nt}{server\PYGZus{}id}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{1}
\PYG{n+nt}{communication}\PYG{p}{:}
    \PYG{n+nt}{address}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{tcp+sbs://127.0.0.1:23012}
\PYG{n+nt}{log}\PYG{p}{:}
    \PYG{n+nt}{version}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{1}
\PYG{n+nt}{module\PYGZus{}engine}\PYG{p}{:}
    \PYG{n+nt}{modules}\PYG{p}{:} \PYG{p+pIndicator}{[}\PYG{p+pIndicator}{]}
\PYG{n+nt}{type}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{event}
\PYG{n+nn}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
Pozivom \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}event \sphinxhyphen{}\sphinxhyphen{}conf conf.yaml}} (ako je minimalna konfiguracija zapisana
u datoteci \sphinxcode{\sphinxupquote{conf.yaml}}) trebao bi se pokrenuti program bez ikakvog ispisa
koji ne zavrsava. Ovaj poziv pokrece sabirnicu dogadaja koja ceka da se na nju
spoje aktori event\sphinxhyphen{}driven sustava (proizvodaci i potrosaci dogdaja). Iduci
korak je implementacija aktora. Spajanje na event server radi se preko
\sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/client.html}{hat.event.client} modula. Taj
modul u sebi sadrzi implementaciju funkcija za spajanje na event server,
primanje i registraciju dogadaja. Funkcija \sphinxcode{\sphinxupquote{connect}} obavlja spajanje na
server i vraca nazad instancu klase \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/client.html\#hat.event.client.Client}{hat.event.client.Client}.
Pozivanjem metoda \sphinxcode{\sphinxupquote{receive}} i \sphinxcode{\sphinxupquote{register}} se primaju ili registriraju
dogadaji.

\sphinxAtStartPar
Dogadaji su uredene trojke koje sadrze atribute \sphinxcode{\sphinxupquote{event\_type}}, \sphinxcode{\sphinxupquote{payload}} i
\sphinxcode{\sphinxupquote{source\_timestamp}}, a konkretna struktura koja se koristi ovisi o tome koja
metoda se pokusava zvati (npr. metoda \sphinxcode{\sphinxupquote{receive}} vraca \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/common/data.html\#hat.event.common.data.Event}{hat.event.common.Event},
dok se metodi \sphinxcode{\sphinxupquote{register}} predaje \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/common/data.html\#hat.event.common.data.RegisterEvent}{hat.event.common.RegisterEvent},
ali obje imaju parametre \sphinxcode{\sphinxupquote{event\_type}}, \sphinxcode{\sphinxupquote{payload}} i \sphinxcode{\sphinxupquote{source\_timestamp}},
razlika je u tome da \sphinxcode{\sphinxupquote{hat.event.common.Event}} ima neke dodatne parametre koje
mu dodijeli server). \sphinxcode{\sphinxupquote{event\_type}} tuple stringova koja sadrzi semanticko
znacenje promjene koja se desila. Po ranije primjeru, \sphinxcode{\sphinxupquote{event\_type}} za dogadaj
koji signalizira promjenu ocitanja mjerenja mogao bi biti \sphinxcode{\sphinxupquote{{[}\textquotesingle{}thermometer1\textquotesingle{},
\textquotesingle{}measurement\_change\textquotesingle{}{]}}}.  \sphinxcode{\sphinxupquote{payload}} sadrzi podatke specificne za promjenu
koja se desila, npr. za primjer promjene mjerenja, on bi mogao biti broj koji
ozacava novoizmjerenu temperaturu. \sphinxcode{\sphinxupquote{source\_timestamp}} je opcionalna vremenska
oznaka u kojoj kreator dogadaja tom dogadaju moze pridruziti oznaku vremena
(npr. kad je izmjerena temperatura). Kako je \sphinxcode{\sphinxupquote{source\_timestamp}} opcionalan, u
svim primjerima cemo ga stavljati u \sphinxcode{\sphinxupquote{None}}.


\subsection{Kreator dogadaja}
\label{\detokenize{hat/event_bus:kreator-dogadaja}}
\sphinxAtStartPar
S ovime na umu, mozemo implementirati prvu skriptu koja ce se ponasti kao
kreator dogadaja. Ona se pokrece, spaja na event server i registrira dogadaj
koji signalizira promjenu nekog arbitrarnog mjerenja. Funkcijom \sphinxcode{\sphinxupquote{connect}}
spojiti cemo se na event server. U konfiguraciji servera, pod
\sphinxcode{\sphinxupquote{communication/address}} vidimo adresu i port na kojoj server slusa. Tu adresu
predajemo prvom argumentu \sphinxcode{\sphinxupquote{connect}} funkcije. Drugi argument,
\sphinxcode{\sphinxupquote{subscriptions}} zasad cemo ostaviti kao praznu listu, a objasnit cemo ga kad
cemo implementirati konzumenta dogadaja za ovaj primjer.

\sphinxAtStartPar
Nakon toga, u beskonacnoj petlji, svake tri sekunde registriramo event ciji je
\sphinxcode{\sphinxupquote{event\_type}} \sphinxcode{\sphinxupquote{(\textquotesingle{}measurement1\textquotesingle{}, \textquotesingle{}change\textquotesingle{}, \textquotesingle{}abc\textquotesingle{})}}, \sphinxcode{\sphinxupquote{source\_timestamp}} je
\sphinxcode{\sphinxupquote{None}}, a \sphinxcode{\sphinxupquote{payload}} je JSON\sphinxhyphen{}serijalizabilna struktura podataka s jednim
atributom, \sphinxcode{\sphinxupquote{value}}, cija vrijednost je nasumicni broj od 0 do 10. To nas
ostavlja s ovakvom konkretnom implementacijom:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{client}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{client} \PYG{o}{=} \PYG{k}{await} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{client}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tcp+sbs://127.0.0.1:23012}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{n}{client}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{p}{[}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{RegisterEvent}\PYG{p}{(}
            \PYG{n}{event\PYGZus{}type}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{measurement1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{change}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
            \PYG{n}{source\PYGZus{}timestamp}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
            \PYG{n}{payload}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayload}\PYG{p}{(}
                \PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayloadType}\PYG{o}{.}\PYG{n}{JSON}\PYG{p}{,}
                \PYG{n}{data}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
        \PYG{k}{await} \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Ovaj program ce se upaliti i raditi dok ga se ne ugasi, bez ispisivanja icega,
ali mozete dodati ispise nasumicnih brojeva koji se registriraju. Takoder,
umjesto \sphinxcode{\sphinxupquote{register}}, postoji metoda \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/client.html\#hat.event.client.Client.register\_with\_response}{register\_with\_response}
koja vrati nazad instance dogadaja koji su se registrirali, zanimljivo bi bilo
vidjeti njihov ispis.


\subsection{Konzument dogadaja}
\label{\detokenize{hat/event_bus:konzument-dogadaja}}
\sphinxAtStartPar
Mogucnost registracije dogadaja nam nema puno koristi ako se ti dogadaji ne
propagiraju do nekih drugih klijenata. Zbog toga imamo potrebu razviti novog
aktora koji bi primao dogadaje koje registrira kreator iz proslog dijela, i
ispisivao ih na konzolu. U proslom dijelu smo kod \sphinxcode{\sphinxupquote{connect}} funkcije
ignorirali argument \sphinxcode{\sphinxupquote{subscriptions}} jer nam tad nije bio potreban, sad cemo
ga koristiti da novostvorenog klijenta „pretplatimo” na dogadaje s odredenom
semantikom. Semantiku dogadaja odreduje njegov \sphinxcode{\sphinxupquote{event\_type}}, koji je izveden
kao tuple stringova. Ako pogledamo potpis \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/client.html\#hat.event.client.connect}{connect}
funkcije, vidimo da je pretplata definirana kao lista tuplova stringova,
odnosno novostvoreni klijent se pretplacuje na n tipova dogadaja.

\sphinxAtStartPar
Nakon stvaranja konekcije s pretplatom, iduca metoda klijenta koja nas zanima
je \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/client.html\#hat.event.client.Client.receive}{receive}.
Kad event server primi dogadaj s tipom koji na koji je klijent pretplacen, on
mu ga posalje. \sphinxcode{\sphinxupquote{receive}} metoda ceka da klijent primi dogadaj i vrati ga na
izlaz.

\sphinxAtStartPar
Na temelju ovoga, mozemo implementirati naseg konzumenta:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{client}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{client} \PYG{o}{=} \PYG{k}{await} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{client}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tcp+sbs://127.0.0.1:23012}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}
            \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{measurement1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{change}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{n}{events} \PYG{o}{=} \PYG{k}{await} \PYG{n}{client}\PYG{o}{.}\PYG{n}{receive}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{events}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Pokrenemo li konzumenta i kreatora istovremeno, vidjet cemo da konzument
ispisuje dogadaje koje kreator registrira. Pokrenemo li vise kreatora i
konzumenata istovremeno, svaki konzument ce ispisivati dogdaje koje
registriraju svi kreatori.

\sphinxAtStartPar
Dodatno, kod implementacije konzumenta, pretplatili smo ga na dogadaje s tipom
\sphinxcode{\sphinxupquote{(\textquotesingle{}measurement1\textquotesingle{}, \textquotesingle{}change\textquotesingle{}, \textquotesingle{}abc\textquotesingle{})}}, ali implementacija klijenta nam
omogucuje i koristenje \sphinxtitleref{wildcard} elemenata \sphinxcode{\sphinxupquote{\textquotesingle{}*\textquotesingle{}}} i \sphinxcode{\sphinxupquote{\textquotesingle{}?\textquotesingle{}}}. \sphinxcode{\sphinxupquote{?}} moze biti
na bilo kojem mjestu unutar pretplate i daje do znanja event serveru da nam je
svejedno sto se nalazi u tipu dogadaja na tom mjestu. Tako bi legitimna
pretplata bila \sphinxcode{\sphinxupquote{(\textquotesingle{}measurement\textquotesingle{}, \textquotesingle{}?\textquotesingle{}, \textquotesingle{}abc\textquotesingle{})}} i konzument bi funkcionirao
jednako. Razlika je da, ako bismo imali aktora koji registrira dogadaje s tipom
\sphinxcode{\sphinxupquote{(\textquotesingle{}measurement\textquotesingle{}, \textquotesingle{}xyz\textquotesingle{}, \textquotesingle{}abc\textquotesingle{})}}, i ti dogadaji bi se ispisivali. Wildcard
\sphinxcode{\sphinxupquote{\textquotesingle{}*\textquotesingle{}}} moze biti samo na kraju pretplate i daje do znanja event serveru da nam
je svejedno sto se nalazi u tipu dogadaja od mjesta gdje je znak postavljen.
Tako bi pretplata \sphinxcode{\sphinxupquote{(\textquotesingle{}measurement\textquotesingle{}, \textquotesingle{}*\textquotesingle{})}} pokrivala \sphinxcode{\sphinxupquote{(\textquotesingle{}measurement\textquotesingle{},
\textquotesingle{}change\textquotesingle{}, \textquotesingle{}abc\textquotesingle{})}} dogadaje, ali i \sphinxcode{\sphinxupquote{(\textquotesingle{}measurement\textquotesingle{})}}, \sphinxcode{\sphinxupquote{(\textquotesingle{}measurement\textquotesingle{},
\textquotesingle{}xyz\textquotesingle{})}}, \sphinxcode{\sphinxupquote{(\textquotesingle{}measurement\textquotesingle{}, \textquotesingle{}123\textquotesingle{}, \textquotesingle{}456\textquotesingle{})}}…


\subsection{Upiti u stare dogadaje}
\label{\detokenize{hat/event_bus:upiti-u-stare-dogadaje}}
\sphinxAtStartPar
Ovaj aspekt event servera nam mozda nece biti potreban u prakticnim zadatcima,
no svejedno ga navodimo radi kompletnosti. Klijenti event servera imaju jos
jednu metodu koju nismo pokrili, \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/client.html\#hat.event.client.Client.query}{query}.
Vidimo po potpisu funkcije da ona predaje argument tipa \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/common/data.html\#hat.event.common.data.QueryData}{QueryData}.
Gledanjem dokumentacije te strukture, vidimo da ona ima puno opcionalnih
argumenata koji izgledaju kao filteri. Kad nad klijentom pozovemo \sphinxcode{\sphinxupquote{query}},
event server primi filtere i na temelju njih napravi upit u bazu podataka kojim
pristupi starim dogadajima koji su se registrirali. Onda vrati te dogadaje i
klijent ih izbaci kao rezultat poziva metode \sphinxcode{\sphinxupquote{query}}.

\sphinxAtStartPar
\sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/common/data.html\#hat.event.common.data.QueryData}{QueryData}
ima razne argumente:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{event\_ids}} filtrira samo one dogadaje s identifikatorima koji su zadani

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{event\_types}} filtrira dogadaje na temelju njihovog tipa (takoder moze
imati wildcardove)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{t\_from}}, \sphinxcode{\sphinxupquote{t\_to}} odreduju pocetak i kraj vremenskog intervala
\sphinxcode{\sphinxupquote{timestamp}} parametra dogadaja (serverova vremenska oznaka)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{source\_t\_from}}, \sphinxcode{\sphinxupquote{source\_t\_to}} odreduju pocetak i kraj vremenskog
intervala \sphinxcode{\sphinxupquote{source\_timestamp}} parametra dogadaja (klijentova vremenska
oznaka)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{payload}} filtrira na temelju \sphinxcode{\sphinxupquote{payload}} parametra dogadaja, gleda se
jednakost

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{order\_by}} odreduje kako ce vraceni dogadaji biti soritrani

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{unique\_type}} daje do znanja event serveru da u rezultatu upita ne vrati
vise dogadaja s istim tipom

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_results}} je cvrsto ogranicenje na maksimalni broj dogdaja koji su
vraceni

\end{itemize}

\sphinxAtStartPar
Mozemo i isprobati ovu funkcionalnost, dosadasnja konfiguracija koristi
implementaciju baze koja ne radi nista, tako da ju je potrebno malo
prilagoditi:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nn}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+nt}{backend\PYGZus{}engine}\PYG{p}{:}
    \PYG{n+nt}{backend}\PYG{p}{:}
        \PYG{n+nt}{module}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{hat.event.server.backends.sqlite}
        \PYG{n+nt}{db\PYGZus{}path}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{hat\PYGZhy{}event.db}
        \PYG{n+nt}{query\PYGZus{}pool\PYGZus{}size}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{1}
    \PYG{n+nt}{server\PYGZus{}id}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{1}
\PYG{n+nt}{communication}\PYG{p}{:}
    \PYG{n+nt}{address}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{tcp+sbs://127.0.0.1:23012}
\PYG{n+nt}{log}\PYG{p}{:}
    \PYG{n+nt}{version}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{1}
\PYG{n+nt}{module\PYGZus{}engine}\PYG{p}{:}
    \PYG{n+nt}{modules}\PYG{p}{:} \PYG{p+pIndicator}{[}\PYG{p+pIndicator}{]}
\PYG{n+nt}{type}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{event}
\PYG{n+nn}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nakon toga, mozemo pokrenuti kreatora dogadaja, da nam registrira
\sphinxcode{\sphinxupquote{(\textquotesingle{}measurement\textquotesingle{}, \textquotesingle{}change\textquotesingle{}, \textquotesingle{}abc\textquotesingle{})}} dogadaje. Paralelno mozemo pokrenuti
sljedecu skriptu koja radi upit na bazu:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{client}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{client} \PYG{o}{=} \PYG{k}{await} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{client}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tcp+sbs://127.0.0.1:23012}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{events} \PYG{o}{=} \PYG{k}{await} \PYG{n}{client}\PYG{o}{.}\PYG{n}{query}\PYG{p}{(}
        \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{QueryData}\PYG{p}{(}
            \PYG{n}{event\PYGZus{}types}\PYG{o}{=}\PYG{p}{[}
                \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{measurement1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{change}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{events}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Na konzoli bi se trebali ispisati svi dogadaji koje je kreator registrirao u
proslosti.

\sphinxAtStartPar
Ovime smo pokrili osnove rada s event serverom koji je zajednicki kod svih
komponenti, a u nastavku cemo vidjeti kako Hat komponente i njihovi
specijalizirani moduli koriste tu infrastrukturu da medusobno suraduju i
implementiraju funkcionalnost industrijskih IoT sustava.


\section{Komponente}
\label{\detokenize{hat/components:komponente}}\label{\detokenize{hat/components::doc}}
\sphinxAtStartPar
Podsjetimo se jos jednom na event\sphinxhyphen{}driven arhitekturu industrijskog IoT sustava:

\sphinxAtStartPar
Spomenuli smo da komponente Hat projekta preslikavaju ovu arhitekturu, na
sljedeci nacin:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://hat-gateway.hat-open.com}{hat\sphinxhyphen{}gateway} komponenta je zaduzena za
komunikaciju s uredajima

\item {} 
\sphinxAtStartPar
specijalizirani moduli \sphinxhref{https://hat-event.hat-open.com}{hat\sphinxhyphen{}event}
komponente su zaduzeni za implementaciju procesne logike

\item {} 
\sphinxAtStartPar
\sphinxhref{https://hat-gui.hat-open.com}{hat\sphinxhyphen{}gui} komponenta je zaduzena za
vizualizaciju

\end{itemize}

\sphinxAtStartPar
Sve tri komponente imaju jednu zajednicku crtu, a to je da su same
implementacije komponenti genericne, ali se konfiguriraju da koriste
implementacije specijaliziranih modula u kojima je sadrzana konkretna domenska
logika specificna za aplikaciju koja se razvija. To konkretno znaci da
komponenta specificira odredeno sucelje koje modul mora zadovoljiti,
implementator sustava napravi implementaciju tog sucelja i kad pokrece
komponentu, u konfiguraciji joj zada da koristi tu implementaciju. Ovako se
onda komponenta vise brine za „infrastrukturne” stvari, poput spajanja na event
server, suradivanja sa specijaliziranim modulima, itd., a specijalizirani
moduli implementiraju aplikaciju.

\sphinxAtStartPar
Prije nego sto se bacimo na konkretne komponente, kratki pregled terminologije
koju cemo koristiti od sad:
\begin{itemize}
\item {} 
\sphinxAtStartPar
device \sphinxhyphen{} specijalizirani modul gateway komponente

\item {} 
\sphinxAtStartPar
modul \sphinxhyphen{} specijalizirani modul event servera

\item {} 
\sphinxAtStartPar
adapter \sphinxhyphen{} specijalizirani modul GUI komponente

\end{itemize}

\sphinxAtStartPar
Pogledajmo sad arhitekturu sustava, sad kad znamo za specijalizirane module:

\noindent\sphinxincludegraphics{{hat-arch-base}.png}


\subsection{Gateway}
\label{\detokenize{hat/components:gateway}}
\noindent\sphinxincludegraphics{{hat-arch-gateway}.png}

\sphinxAtStartPar
Gateway komponenta upravlja svojim specijaliziranim modulima, devicevima, cija
zaduzenja su komunikacija s uredajima i pretvorba podataka koje prime preko te
komunikacije u dogadaje. Ona se pokrece pozivom \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}gateway}} kojem se preko
argument \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}conf}} zadaje konfiguracija u JSON ili YAML formatu. Konfiguracija
je specificirana \sphinxhref{https://github.com/hat-open/hat-gateway/blob/master/schemas\_json/main.yaml}{JSON shemom},
a jedan minimalni primjer mogao bi biti:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nn}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+nt}{type}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{gateway}
\PYG{n+nt}{event\PYGZus{}server\PYGZus{}address}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{tcp+sbs://127.0.0.1:23012}
\PYG{n+nt}{gateway\PYGZus{}name}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{gateway1}
\PYG{n+nt}{devices}\PYG{p}{:}
    \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{module}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{devices.ammeter}
      \PYG{n+nt}{name}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{ammeter1}
\PYG{n+nt}{log}\PYG{p}{:}
    \PYG{n+nt}{disable\PYGZus{}existing\PYGZus{}loggers}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{false}
    \PYG{n+nt}{formatters}\PYG{p}{:}
        \PYG{n+nt}{default}\PYG{p}{:} \PYG{p+pIndicator}{\PYGZob{}}\PYG{p+pIndicator}{\PYGZcb{}}
    \PYG{n+nt}{handlers}\PYG{p}{:}
        \PYG{n+nt}{console}\PYG{p}{:}
            \PYG{n+nt}{class}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{logging.StreamHandler}
            \PYG{n+nt}{level}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{INFO}
            \PYG{n+nt}{stream}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{ext://sys.stdout}
    \PYG{n+nt}{root}\PYG{p}{:}
        \PYG{n+nt}{handlers}\PYG{p}{:}
        \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{console}
        \PYG{n+nt}{level}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{INFO}
    \PYG{n+nt}{version}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{1}
\PYG{n+nn}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
Najzanimljiviji argumenti ovdje su nam \sphinxcode{\sphinxupquote{devices}} i \sphinxcode{\sphinxupquote{gateway\_name}}.
\sphinxcode{\sphinxupquote{gateway\_name}} ce nam biti bitan kasnije jer ce biti sadrzan u tipu dogadaja
s kojim rade devicevi (i njihovi konzumenti). \sphinxcode{\sphinxupquote{devices}} sadrzi postavke
specijaliziranih modula, konfigurira se jedan device ciji modul je
implementiran u \sphinxcode{\sphinxupquote{devices.ammeter}} (gateway ce u nekom trenutku pozvati liniju
\sphinxcode{\sphinxupquote{import devices.ammeter}}). On ima pridruzen i \sphinxcode{\sphinxupquote{name}} koji ima slicnu svrhu
kao i \sphinxcode{\sphinxupquote{gateway\_name}}, bit ce bitan kasnije jer ce biti sadrzan u tipu
dogadaja konkretnog devicea. \sphinxcode{\sphinxupquote{log}} polje mozda izgleda zastrasujuce, ali to
je zapravo samo konfiguracija Pythonvog \sphinxcode{\sphinxupquote{logging}}  modula koja se ovdje
konfigurira da ispisuje logove na konzolu.

\sphinxAtStartPar
Pogledajmo sada \sphinxhref{https://hat-gateway.hat-open.com/py\_api/hat/gateway/common.html\#hat.gateway.common.Device}{sucelje}
koje pojedina implementacija devicea mora zadovoljiti. Vidimo da ona mora biti
izvedena kao Python modul, koji ima globalne varijable \sphinxcode{\sphinxupquote{device\_type}},
\sphinxcode{\sphinxupquote{json\_schema\_id}} i \sphinxcode{\sphinxupquote{json\_schema\_repo}}, te funkciju \sphinxcode{\sphinxupquote{create}}.
\sphinxcode{\sphinxupquote{device\_type}} sluzi za klasifikaciju tipa uredaja s kojim komuniciramo,
obicno bude jednak imenu protokola koji se koristi. Namjena mu je slicna kao i
ranije spomenutim \sphinxcode{\sphinxupquote{gateway\_name}} i \sphinxcode{\sphinxupquote{device\_name}} konfiguracijskim
parametrima, budu elementi unutar tipa dogadaja koji se odnose na taj device.
\sphinxcode{\sphinxupquote{json\_schema\_id}} i \sphinxcode{\sphinxupquote{json\_schema\_repo}} su opcionalni pa ih necemo koristiti,
a odnose se na mogucnost konfiguriranja devicea. Svaki device moze propisivati
svoju strukturu konfiguracije, a format za specifikaciju te strukture je JSON
shema. Repo sadrzi shemu a ID kaze s kojim ID\sphinxhyphen{}em u shemi se konfiguracija
usporeduje. Opcionalni su, tako da ce u nasim primjerima uvijek biti \sphinxcode{\sphinxupquote{None}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{create}} funkcija zaduzena je za stvaranje instance klase \sphinxhref{https://hat-gateway.hat-open.com/py\_api/hat/gateway/common.html\#hat.gateway.common.Device}{Device}.
Po dokumentaciji, ona prima tri argumenta: event klijent, konfiguraciju i
„prefiks” tipa dogadaja. S event klijentom smo se bavili u proslom dijelu,
takvog klijenta primamo ovdje i mozemo ga koristiti na isti nacin. Moze se
primjetiti da on nije bas istog tipa kao i event klijent iz proslog dijela,
razlog tome je cinjenica da gateway komponenta stvara svoj wrapper oko
originalne instance iz nekih infrastrukturnih razloga (jedan „pravi” klijent za
cijeli gateway, odredba pretplata itd.). Konfiguracija je drugi argument, ona
je jednaka bilo cemu sto se zapise u konfiguraciji gatewaya u elementima polja
\sphinxcode{\sphinxupquote{devices}}. Treci argument, prefiks tipa dogadaja je zapravo tuple stringova
\sphinxcode{\sphinxupquote{(\textquotesingle{}gateway\textquotesingle{}, gateway\_name, device\_type, device\_name)}}. Za tip dogadaja smo
odredili da je definiran kao tuple stringova, svi dogadaji s kojima device radi
moraju imati ovaj prefiks. To znaci da svaki dogadaj kojeg device registrira bi
trebao pocinjati s ova 4 stringa, npr. \sphinxcode{\sphinxupquote{(\textquotesingle{}gateway\textquotesingle{}, \textquotesingle{}gateway1\textquotesingle{}, \textquotesingle{}iec104\textquotesingle{},
\textquotesingle{}iec104\_device1\textquotesingle{}, \textquotesingle{}measurement\_change\textquotesingle{})}}, ako je ime gatewaya \sphinxcode{\sphinxupquote{gateway1}},
tip devicea \sphinxcode{\sphinxupquote{iec104}}, a ime \sphinxcode{\sphinxupquote{iec104\_device1}}. Gatway komponenta ne
prisiljava da bude ovaj prefiks, to je samo dobra praksa. Ista stvar vrijedi i
za primanje dogadaja, \sphinxcode{\sphinxupquote{receive}} metoda event klijenta kojeg device primi u
\sphinxcode{\sphinxupquote{create}} funkciji vracati ce samo dogadaje kao da je pretplacena na
\sphinxcode{\sphinxupquote{(*event\_type\_prefix, \textquotesingle{}*\textquotesingle{})}}. Nije specificirano u prefiksu, ali nakon njega
se obicno navodi smjer komunikacije, odnosno ako dogadaj registrira device onda
je to \sphinxcode{\sphinxupquote{gateway}} a ako ga registrira neki drugi aktor a device ga treba
primati, smjer je \sphinxcode{\sphinxupquote{system}}. Opet, komponenta ne prisiljava ovo ali se potice.

\sphinxAtStartPar
Sad mozemo pogledati neku konkretnu implementaciju gateway devicea. Uzeti cemo
raniji primjer s ampermetrima i pretvoriti klasu funkcije \sphinxcode{\sphinxupquote{Communication}} i
preraditi ju da vise ne zove \sphinxcode{\sphinxupquote{process}}, vec samo registrira dogadaj i ne
brine sto se dalje dogada s njim:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{drivers} \PYG{k+kn}{import} \PYG{n}{iec104}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{aio}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{gateway}\PYG{n+nn}{.}\PYG{n+nn}{common}


\PYG{n}{json\PYGZus{}schema\PYGZus{}id} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{json\PYGZus{}schema\PYGZus{}repo} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{device\PYGZus{}type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ammeter}\PYG{l+s+s1}{\PYGZsq{}}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{,} \PYG{n}{event\PYGZus{}client}\PYG{p}{,} \PYG{n}{event\PYGZus{}type\PYGZus{}prefix}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{device} \PYG{o}{=} \PYG{n}{AmmeterDevice}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{device}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{aio}\PYG{o}{.}\PYG{n}{Group}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{device}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}client} \PYG{o}{=} \PYG{n}{event\PYGZus{}client}
    \PYG{n}{device}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}type\PYGZus{}prefix} \PYG{o}{=} \PYG{n}{event\PYGZus{}type\PYGZus{}prefix}
    \PYG{n}{device}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}\PYG{o}{.}\PYG{n}{spawn}\PYG{p}{(}\PYG{n}{device}\PYG{o}{.}\PYG{n}{\PYGZus{}main\PYGZus{}loop}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{device}


\PYG{k}{class} \PYG{n+nc}{AmmeterDevice}\PYG{p}{(}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{gateway}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Device}\PYG{p}{)}\PYG{p}{:}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}group}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{\PYGZus{}main\PYGZus{}loop}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{connection} \PYG{o}{=} \PYG{k}{await} \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}
            \PYG{n}{iec104}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{127.0.0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{9999}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
            \PYG{n}{data} \PYG{o}{=} \PYG{p}{(}\PYG{k}{await} \PYG{n}{connection}\PYG{o}{.}\PYG{n}{receive}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}client}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{p}{[}
                \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{RegisterEvent}\PYG{p}{(}
                    \PYG{n}{event\PYGZus{}type}\PYG{o}{=}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}type\PYGZus{}prefix}\PYG{p}{,}
                                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gateway}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{asdu\PYGZus{}address}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                    \PYG{n}{source\PYGZus{}timestamp}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
                    \PYG{n}{payload}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayload}\PYG{p}{(}
                        \PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayloadType}\PYG{o}{.}\PYG{n}{JSON}\PYG{p}{,}
                        \PYG{n}{data}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{value}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Jedna nejasnoca koja bi se mogla javiti citanjem ovog koda je svrha
\sphinxcode{\sphinxupquote{hat.aio.Group}} klase, koristenja njene \sphinxcode{\sphinxupquote{spawn}} metode, njenog vracanja
kroz property \sphinxcode{\sphinxupquote{async\_group}}, … Property \sphinxcode{\sphinxupquote{async\_group}} je potreban zbog
sucelja koje propisuje \sphinxcode{\sphinxupquote{hat.gateway.common.Device}} (on nasljeduje
\sphinxcode{\sphinxupquote{hat.aio.Resource}}, a on propisuje da mora postojati taj property). Ideja je
da se instanca tog objekta koristi za odredivanje zivotnog ciklusa devicea.
Instanca moze biti u otvorenom ili zatvorenom stanju, otvoreno stanje oznacava
da device treba raditi, a zatvoreno da ne treba. Metoda \sphinxcode{\sphinxupquote{spawn}} od grupe
ponasa se slicno kao \sphinxhref{https://docs.python.org/3/library/asyncio-task.html\#asyncio.create\_task}{asyncio.create\_task},
glavna razlika je da Task koji bi se vratio se veze uz stanje otvorenosti grupe
\sphinxhyphen{} ako se grupa ikad zatvori, Task ce se otkazati (poziv \sphinxcode{\sphinxupquote{Task.cancel}}) \sphinxhyphen{} ovo
nam ide u korist jer onda stanje otvorenosti grupe zaista upravlja cinjenicom
izvrsava li se \sphinxcode{\sphinxupquote{\_main\_loop}} ili ne.

\sphinxAtStartPar
Jedan detalj nismo spomenuli, a bitan je za pokretanje gatewaya s deviceom, je
potreba za registracijom dogadaja za paljenje devicea. U \sphinxhref{https://hat-gateway.hat-open.com/gateway.html\#event-server-communication}{dokumentaciji}
mozemo vidjeti kakvu strukturu imaju ti dogadaji. Dakle, potrebno je
registrirati dogadaj s tipom \sphinxcode{\sphinxupquote{(*prefiks, \textquotesingle{}system\textquotesingle{}, \textquotesingle{}enable\textquotesingle{})}} i payloadom
\sphinxcode{\sphinxupquote{True}} jer to signalizira gateway komponenti da pokrene device koji smo
konfigurirali.  Najjednostavnije to mozemo napraviti s odvojenom skriptom:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{client}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{k+kn}{import} \PYG{n+nn}{sys}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{client} \PYG{o}{=} \PYG{k}{await} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{client}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tcp+sbs://127.0.0.1:23012}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{await} \PYG{n}{client}\PYG{o}{.}\PYG{n}{register\PYGZus{}with\PYGZus{}response}\PYG{p}{(}\PYG{p}{[}
        \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{RegisterEvent}\PYG{p}{(}
            \PYG{n}{event\PYGZus{}type}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gateway}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gateway1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ammeter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ammeter1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{system}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{enable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
            \PYG{n}{source\PYGZus{}timestamp}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
            \PYG{n}{payload}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayload}\PYG{p}{(}
                \PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayloadType}\PYG{o}{.}\PYG{n}{JSON}\PYG{p}{,}
                \PYG{n}{data}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{async\PYGZus{}main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exit}\PYG{p}{(}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Jos detalja za pokretanje, event server mora biti startan, gateway ga ocekuje
na adresi \sphinxcode{\sphinxupquote{tcp+sbs://127.0.0.1:23012}}. Uz to, treba pokrenuti i simulator iz
prvog zadatka, inace ce device izbaciti exception jer connect nece proci.

\sphinxAtStartPar
Prilagodimo li sad naseg ranijeg konzumenta dogadaja (ili skriptu za upite) da
prate dogadaje tipa \sphinxcode{\sphinxupquote{(\textquotesingle{}gateway\textquotesingle{}, \textquotesingle{}gateway1\textquotesingle{}, \textquotesingle{}ammeter\textquotesingle{}, \textquotesingle{}ammeter1\textquotesingle{}, \textquotesingle{}*\textquotesingle{})}},
vidjeli bismo da se zaista registriraju ovi dogadaji, nakon \sphinxcode{\sphinxupquote{ammeter}} dijela
je identifikator mjerenja (ASDU adresa iz proslog zadatka), a payload je broj
koji predstavlja iznos mjerenja. Ako ima problema oko starta gatewaya, tipa
dolazi do ispisa greske \sphinxcode{\sphinxupquote{No module named ...}}, dodajte direktorij iz kojeg
pokrecete u environment varijablu \sphinxcode{\sphinxupquote{PYTHONPATH}} (\sphinxhref{https://askubuntu.com/a/58828}{linux (bash)}, \sphinxhref{http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-windows-command-line-and-registry/}{windows}).

\sphinxAtStartPar
Iduci korak je procesna logika u kojem cemo razviti specijalizirani modul koji
ce primati informacije o strujama od devicea i stvarati nove dogadaje na
temelju njih.


\subsection{Event server}
\label{\detokenize{hat/components:event-server}}
\noindent\sphinxincludegraphics{{hat-arch-event}.png}

\sphinxAtStartPar
Event server smo vec vidjeli u situacijama gdje implementira sabirnicu
dogadaja, a sad cemo vidjeti kako pomocu njegovih specijaliziranih modula
mozemo implementirati procesnu logiku aplikacije. Ona se izvodi tako da se
specijalizirani moduli event servera pretplate na dogadaje odredenog tipa i,
kad se dogadaji s tim tipom registriraju, stvore nove dogadaje na temelju njih.

\sphinxAtStartPar
Mozemo preuzeti konfiguraciju iz proslog dijela, glavna razlika je da cemo sad
u \sphinxcode{\sphinxupquote{module\_engine/modules}} dodati konfiguraciju specijaliziranog modula:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nn}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+nt}{type}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{event}
\PYG{n+nt}{backend\PYGZus{}engine}\PYG{p}{:}
    \PYG{n+nt}{backend}\PYG{p}{:}
        \PYG{n+nt}{module}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{hat.event.server.backends.dummy}
    \PYG{n+nt}{server\PYGZus{}id}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{1}
\PYG{n+nt}{communication}\PYG{p}{:}
    \PYG{n+nt}{address}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{tcp+sbs://127.0.0.1:23012}
\PYG{n+nt}{module\PYGZus{}engine}\PYG{p}{:}
    \PYG{n+nt}{modules}\PYG{p}{:}
      \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{module}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{modules.state}
\PYG{n+nt}{log}\PYG{p}{:}
    \PYG{n+nt}{disable\PYGZus{}existing\PYGZus{}loggers}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{false}
    \PYG{n+nt}{formatters}\PYG{p}{:}
        \PYG{n+nt}{default}\PYG{p}{:} \PYG{p+pIndicator}{\PYGZob{}}\PYG{p+pIndicator}{\PYGZcb{}}
    \PYG{n+nt}{handlers}\PYG{p}{:}
        \PYG{n+nt}{console}\PYG{p}{:}
            \PYG{n+nt}{class}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{logging.StreamHandler}
            \PYG{n+nt}{level}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{INFO}
            \PYG{n+nt}{stream}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{ext://sys.stdout}
    \PYG{n+nt}{root}\PYG{p}{:}
        \PYG{n+nt}{handlers}\PYG{p}{:}
        \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{console}
        \PYG{n+nt}{level}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{INFO}
    \PYG{n+nt}{version}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{1}
\PYG{n+nn}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
Dakle, u odnosu na dio gdje smo se fokusirali na nacin kako slati dogadaje
preko event servera, ovdje je razlika da smo dodali specijalizirani modul
\sphinxcode{\sphinxupquote{modules.state}} (kao i kod gatewaya, ovo je Python ime modula, u nekom
trenutku event server ce zvati \sphinxcode{\sphinxupquote{import modules.state}}).

\sphinxAtStartPar
Sad je potrebno zaista implementirati modul. Gledanjem \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/server/common.html\#hat.event.server.common.Module}{dokumentacije},
mozemo vidjeti da se to radi tako da definiramo modul tako da implementiramo
Python modul koji ima globalne varijable \sphinxcode{\sphinxupquote{json\_schema\_id}},
\sphinxcode{\sphinxupquote{json\_schema\_repo}} i funkciju \sphinxcode{\sphinxupquote{create}}. Kod globalnih varijabli vrijedi
ista prica kao i kod deviceva, a \sphinxcode{\sphinxupquote{create}} je korutina koja vraca instancu
klase \sphinxcode{\sphinxupquote{hat.event.server.common.Module}}. Ona prima konfiguraciju modula i
referencu na instancu klase \sphinxcode{\sphinxupquote{hat.event.module\_engine.ModuleEngine}}.
Konfiguracija modula je iz konfiguracije cijelog event servera, ono sto je
napisano uz \sphinxcode{\sphinxupquote{module: \textless{}Python ime modula\textgreater{}}}, a module engine je objekt koji
sluzi kao sucelje event servera prema modulu. Ako pogledamo \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/server/module\_engine.html}{njegovu
dokumentaciju},
vidimo da ima slicne metode kao event klijent.

\sphinxAtStartPar
Kao i device, modul nasljeduje \sphinxcode{\sphinxupquote{hat.aio.Resource}} abstraktnu klasu, pa mora
imati \sphinxcode{\sphinxupquote{async\_group}} property.  Uz njega, ima i property \sphinxcode{\sphinxupquote{subscription}}
kojim se specificira na kakve dogadaje se modul pretplacuje (mala razlika je da
to sad vise nije lista tupleova, vec se predaje
\sphinxcode{\sphinxupquote{hat.event.common.subscription.Subscription}} objektu).

\sphinxAtStartPar
Metoda \sphinxcode{\sphinxupquote{create\_session}} je iduca komplikacija. Ideja je da moduli zapravo ne
obavljaju registraciju dogadaja sami po sebi, vec da stvaraju sesije koje to
rade za njih. Ovo je vise do implementacijskih detalja event servera, gdje kad
se registrira dogadaj, event server stvori sesiju svakog modula i onda, ako se
modul pretplacuje na dogadaj koji se registrirao, koristi tu sesiju da stvori
nove dogadaje. Implementator modula ima korist od toga jer moze imati
distinkciju izmedu razlicitih sekvenci obrada podataka, necega za cime nemamo
potrebu u sklopu nasih zadataka \sphinxhyphen{} zbog toga cemo obradu podataka u sesiji
obicno samo proslijediti nazad modulu. \sphinxcode{\sphinxupquote{create\_session}} ne prima nikakve
argumente, a vraca instancu objekta \sphinxcode{\sphinxupquote{hat.event.server.common.ModuleSession}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ModuleSession}} je abstraktna klasa koja nasljeduje \sphinxcode{\sphinxupquote{hat.aio.Resource}},
dakle ima property \sphinxcode{\sphinxupquote{async\_group}} iz istih razloga kao i device i modul. Uz
to, ima i metodu \sphinxcode{\sphinxupquote{process}} koja prima i vraca listu dogadaja. Lista koju
prima je sadrzi dogadaje na koje se modul predplacuje kroz \sphinxcode{\sphinxupquote{subscription}}
property, a lista koju vraca je sadrzi nove dogadaje koje zeli registrirati.
Mala razlika u odnosu na dosadasnji rad s registracijom dogdaja je da se ovdje
ne koristi \sphinxcode{\sphinxupquote{RegisterEvent}}, vec je potrebno vratiti
\sphinxcode{\sphinxupquote{hat.event.server.common.ProcessEvent}}. On se stvara pozivom module engineove
metode \sphinxcode{\sphinxupquote{create\_process\_event}}. On prima dogadaj i identifikator izvora
dogadaja, \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/server/common.html\#hat.event.server.common.Source}{hat.event.server.common.Source},
pa je dodatno u sesiji potrebno negdje drzati referencu i na njega.

\sphinxAtStartPar
Uz sve ovo imamo dovoljno informacija da napravimo primjer event server modula.
Uzeti cemo opet slucaj iz prvog zadatka s ampermetrima, a ovdje cemo napraviti
modul koji ce raditi istu stvar kao i \sphinxcode{\sphinxupquote{Processing}} klasa, uparivanje
primljenog mjerenja sa strujama I1, I2 i I3, te racunanje struje I4. Ona bi
izgledala ovako:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{aio}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{server}\PYG{n+nn}{.}\PYG{n+nn}{common}


\PYG{n}{json\PYGZus{}schema\PYGZus{}id} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{json\PYGZus{}schema\PYGZus{}repo} \PYG{o}{=} \PYG{k+kc}{None}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{,} \PYG{n}{engine}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{module} \PYG{o}{=} \PYG{n}{StateModule}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{global} \PYG{n}{\PYGZus{}source\PYGZus{}id}
    \PYG{n}{module}\PYG{o}{.}\PYG{n}{\PYGZus{}source} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Source}\PYG{p}{(}
        \PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{SourceType}\PYG{o}{.}\PYG{n}{MODULE}\PYG{p}{,}
        \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{modules.state}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{n}{module}\PYG{o}{.}\PYG{n}{\PYGZus{}subscription} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Subscription}\PYG{p}{(}\PYG{p}{[}
        \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gateway}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gateway1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ammeter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ammeter1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gateway}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{?}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{module}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{aio}\PYG{o}{.}\PYG{n}{Group}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{module}\PYG{o}{.}\PYG{n}{\PYGZus{}engine} \PYG{o}{=} \PYG{n}{engine}
    \PYG{n}{module}\PYG{o}{.}\PYG{n}{\PYGZus{}state} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}

    \PYG{k}{return} \PYG{n}{module}


\PYG{k}{class} \PYG{n+nc}{StateModule}\PYG{p}{(}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Module}\PYG{p}{)}\PYG{p}{:}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}group}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{subscription}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}subscription}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}session}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{StateModuleSession}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}\PYG{o}{.}\PYG{n}{create\PYGZus{}subgroup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{module\PYGZus{}process}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{changes}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{event} \PYG{o}{=} \PYG{n}{changes}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{c+c1}{\PYGZsh{} dohvat zadnjeg elementa tipa dogadaja, za uparivanje s I1, I2, I3}
        \PYG{n}{measurement\PYGZus{}id} \PYG{o}{=} \PYG{n}{event}\PYG{o}{.}\PYG{n}{event\PYGZus{}type}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{current} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{measurement\PYGZus{}id}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{current} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{n}{current}\PYG{p}{]} \PYG{o}{=} \PYG{n}{event}\PYG{o}{.}\PYG{n}{payload}\PYG{o}{.}\PYG{n}{data}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                             \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                             \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
        \PYG{k}{return} \PYG{p}{[}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}engine}\PYG{o}{.}\PYG{n}{create\PYGZus{}process\PYGZus{}event}\PYG{p}{(}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}source}\PYG{p}{,}
                \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{RegisterEvent}\PYG{p}{(}
                    \PYG{n}{event\PYGZus{}type}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{)}\PYG{p}{,}
                    \PYG{n}{source\PYGZus{}timestamp}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
                    \PYG{n}{payload}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayload}\PYG{p}{(}
                        \PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayloadType}\PYG{o}{.}\PYG{n}{JSON}\PYG{p}{,}
                        \PYG{n}{data}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}state}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}


\PYG{k}{class} \PYG{n+nc}{StateModuleSession}\PYG{p}{(}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{ModuleSession}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{module}\PYG{p}{,} \PYG{n}{group}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}module} \PYG{o}{=} \PYG{n}{module}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}group} \PYG{o}{=} \PYG{n}{group}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}group}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}group}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{process}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{changes}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} delegacija obrade dogadaja nazad modulu}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}module}\PYG{o}{.}\PYG{n}{module\PYGZus{}process}\PYG{p}{(}\PYG{n}{changes}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Ovaj modul pretplacuje se na dogadaje koje registrira device i kreira svoje
dogadaje koji sadrze stanje, u istom formatu kao i u prvom zadatku.


\subsection{GUI server}
\label{\detokenize{hat/components:gui-server}}
\noindent\sphinxincludegraphics{{hat-arch-gui}.png}

\sphinxAtStartPar
Zadnja komponenta na koju se fokusiramo je GUI server, a ona sluzi za
vizualizaciju podataka. Ona se, s jedne strane, spaja na event server i
ukljucuje u interakciju s dogadajima, a, s druge, posluzuje HTTP servis na koji
se korisnici mogu spojiti svojim web browserima i pregledati stanje sustava.
Stanje sustava prezentira se kroz genericnu web aplikaciju, koja se moze
konfigurirati da prikazuje preglede koje implementator sustava implementira.
Aplikacija je implementirana u JavaScriptu i komunicira s GUI serverom pomocu
WebSocket protokola, odnosno \sphinxhref{https://hat-juggler.hat-open.com/}{hat\sphinxhyphen{}juggler}
wrappera. Konkretan format stanja koje GUI server salje klijentskoj aplikaciji
propisuju specijalizirani moduli GUI servera, adapteri.

\sphinxAtStartPar
Komponenta se pokrece pozivom \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}gui}} u komandnoj liniji. Zadaje joj se
argument \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}conf}} koji sadrzi putanju do JSON ili YAML konfiguracije koja
sadrzi konkretne postavke. Format konfiguracije propisan je \sphinxhref{https://github.com/hat-open/hat-gui/blob/master/schemas\_json/main.yaml}{JSON shemom}, a
jedan minimalni primjer mogao bi biti:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nn}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+nt}{type}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{gui}
\PYG{n+nt}{event\PYGZus{}server\PYGZus{}address}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{tcp+sbs://127.0.0.1:23012}
\PYG{n+nt}{address}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{http://0.0.0.0:23023}
\PYG{n+nt}{views}\PYG{p}{:}
  \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{name}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{login}
    \PYG{n+nt}{view\PYGZus{}path}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{./views/login}
    \PYG{n+nt}{conf\PYGZus{}path}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{null}
  \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{name}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{main}
    \PYG{n+nt}{view\PYGZus{}path}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{./views/main}
    \PYG{n+nt}{conf\PYGZus{}path}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{null}
\PYG{n+nt}{initial\PYGZus{}view}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{login}
\PYG{n+nt}{users}\PYG{p}{:}
  \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{name}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{user1}
    \PYG{n+nt}{password}\PYG{p}{:}
        \PYG{n+nt}{hash}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{0927f26c1e200037ef44e622d39d5b7c201690c85b9aa86545d6583ecff2b02f}
        \PYG{n+nt}{salt}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{7af08c40f25d800fa3d1ab3f8199adbd}
    \PYG{n+nt}{roles}\PYG{p}{:}
        \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{user}
    \PYG{n+nt}{view}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{main}
\PYG{n+nt}{adapters}\PYG{p}{:}
  \PYG{p+pIndicator}{\PYGZhy{}} \PYG{n+nt}{module}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{adapters.state}
    \PYG{n+nt}{name}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{state}
\PYG{n+nt}{log}\PYG{p}{:}
    \PYG{n+nt}{disable\PYGZus{}existing\PYGZus{}loggers}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{false}
    \PYG{n+nt}{formatters}\PYG{p}{:}
        \PYG{n+nt}{default}\PYG{p}{:} \PYG{p+pIndicator}{\PYGZob{}}\PYG{p+pIndicator}{\PYGZcb{}}
    \PYG{n+nt}{handlers}\PYG{p}{:}
        \PYG{n+nt}{console}\PYG{p}{:}
            \PYG{n+nt}{class}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{logging.StreamHandler}
            \PYG{n+nt}{level}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{INFO}
            \PYG{n+nt}{stream}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{ext://sys.stdout}
    \PYG{n+nt}{root}\PYG{p}{:}
        \PYG{n+nt}{handlers}\PYG{p}{:}
        \PYG{p+pIndicator}{\PYGZhy{}} \PYG{l+lScalar+lScalarPlain}{console}
        \PYG{n+nt}{level}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{INFO}
    \PYG{n+nt}{version}\PYG{p}{:} \PYG{l+lScalar+lScalarPlain}{1}
\PYG{n+nn}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
Konfiguriraju se razne adrese, jedna za spajanje s event serverom, druga na
kojoj GUI server posluzuje podatke… Konfiguriraju se i viewovi, to su
spomenuti pregledi koje mi trebamo implementirati. Nakon toga slijedi
konfiguracija korisnika. GUI server obavlja rudimentarno upravljanje
korisnicima, u konfiguraciji se navode login podatci. Za lozinke se ocekuje da
su hashirane SHA256 algoritmom, i da je \sphinxhref{https://en.wikipedia.org/wiki/Salt\_(cryptography)}{„posoljen”} s nasumicnim bajtima u
\sphinxcode{\sphinxupquote{salt}} polju i ponovno hashiran. Za potrebe nasih primjera, ove stvari ce
biti hardkodirane, uvijek koristimo postavke iz ove konfiguracije, a za
korisnika \sphinxcode{\sphinxupquote{user1}} lozinka je \sphinxcode{\sphinxupquote{pass1}}. Uz login podatke a korisnika se moze
definirati koju ulogu (\sphinxcode{\sphinxupquote{role}}) ima \sphinxhyphen{} na ovaj nacin moze se napraviti
distinkcija izmedu administratora i obicnih korisnika te koji view korisnik
vidi nakon sto se prijavi. Konacno, nakon korisnika ide konfiguracija
specijaliziranih modula, adaptera. Vidimo slicnu strukturu kao i kod
gatewayovih deviceva, zadaje se Python ime modula (npr. ovdje ce se u nekom
trenutku zvati \sphinxcode{\sphinxupquote{import adapters.state}}) i ime adaptera koje ce se koristiti
da identificira taj adapter u komunikaciji s event serverom i klijentskom
aplikacijom.

\sphinxAtStartPar
Razvoj viewova, odnosno grafickih prikaza je tema za sebe koja ce biti
pokrivena u odvojenom poglavlju. U ovom primjeru koristiti cemo gotovu,
izbuildanu verziju viewova, a GUI server cemo samo konfigurirati da koristi te
prikaze.

\sphinxAtStartPar
Glavni dio razvoja na serverskoj strani je implementacija adaptera. Pogledajmo
sad \sphinxhref{https://hat-gui.hat-open.com/py\_api/hat/gui/common.html\#hat.gui.common.Adapter}{sucelje}
koje ovi specijalizirani moduli moraju implementirati. Vidimo da on mora biti
izveden kao odvojeni Python modul s globalnim varijablama \sphinxcode{\sphinxupquote{json\_schema\_id}} i
\sphinxcode{\sphinxupquote{json\_schema\_repo}} te funkcijama \sphinxcode{\sphinxupquote{create\_subscription}} i
\sphinxcode{\sphinxupquote{create\_adapter}}. Za globalne varijable vrijede iste primjedbe kao i kod
deviceva i event server modula, to su opcionalne varijabe koje sluze za
validaciju konfiguracije koja je postavljena te ce biti \sphinxcode{\sphinxupquote{None}} u nasim
primjerima. \sphinxcode{\sphinxupquote{create\_subscription}} treba moci primiti jedan argument,
konfiguraciju adaptera, a vraca instancu \sphinxhref{https://hat-event.hat-open.com/py\_api/hat/event/common/index.html\#hat.event.common.Subscription}{hat.event.common.Subscription}
klase u kojoj se navodi na kakve tipove dogadaja se adapter pretplacuje.
Konacno, \sphinxcode{\sphinxupquote{create\_adapter}} funkcija prima konfiguraciju adaptera i event
klijent, a vraca instancu klase \sphinxcode{\sphinxupquote{hat.gui.common.Adapter}}.

\sphinxAtStartPar
Ako pogledamo klasu \sphinxcode{\sphinxupquote{hat.gui.common.Adapter}} vidimo da ona nasljeduje
\sphinxcode{\sphinxupquote{hat.aio.Resource}}, dakle, kao i devicevi i event server moduli, mora imati
property \sphinxcode{\sphinxupquote{async\_group}}. Uz to sama adapterova klasa propisuje da mora
postojati metoda \sphinxcode{\sphinxupquote{create\_session}} koja prima jedan argument tipa
\sphinxhref{https://hat-gui.hat-open.com/py\_api/hat/gui/common.html\#hat.gui.common.AdapterSessionClient}{hat.gui.common.AdapterSessionClient}.
Slicno kao i moduli event servera, adapteri nece sami direktno komunicirati sa
svojim klijetima, vec imaju sesije. U ovom kontekstu, jedna sesija predstavlja
vezu na jednog klijenta koji je spojen na GUI server (mozemo to zamisliti kao
da svaka otvorena sesija predstavlja jedan web browser koji je spojen na nas
server). Vidimo da \sphinxhref{https://hat-gui.hat-open.com/py\_api/hat/gui/common.html\#hat.gui.common.AdapterSession}{hat.gui.common.AdapoterSession}
zapravo nema nikakve dodatne metode i propertyje (osim, opet, \sphinxcode{\sphinxupquote{async\_group}}
jer je instance \sphinxcode{\sphinxupquote{hat.aio.Resource}}). To znaci da imamo slobodu bilo kako
implementirati kako se tocno koristi \sphinxcode{\sphinxupquote{AdapterSessionClient}} za komunikaciju s
klijentima.

\sphinxAtStartPar
Preko \sphinxcode{\sphinxupquote{AdapterSessionClient}}\sphinxhyphen{}a adapterova sesija komunicira s web aplikacijom
u browseru. Vidimo da ona ima slicne metode i propertyje kao i \sphinxhref{https://hat-juggler.hat-open.com/python.html}{juggler
konekcija} (jer nam GUI server
zapravo predaje wrapper oko nje). Kod jugglera je ideja da povezuje dvije
komunikacijske tocke s WebSocket protokolom. WebSocket se inace specijalizira
za slanje poruka, a juggler nam pruza podrsku za neke dodatne funkcije. Jedna
od tih funkcija je sinkronizacija stanja \sphinxhyphen{} vidimo da \sphinxcode{\sphinxupquote{Connection}} (i
\sphinxcode{\sphinxupquote{AdapterSessionClient}}) ima propertyje \sphinxcode{\sphinxupquote{local\_data}} i \sphinxcode{\sphinxupquote{remote\_data}}.
Jedna strana komunikacije moze u \sphinxcode{\sphinxupquote{local\_data}} zapisati bilo kakav JSON
serijalizabilni objekt (preko metode \sphinxcode{\sphinxupquote{set\_local\_data}}), i on ce se drugoj
strani pojaviti u njenom \sphinxcode{\sphinxupquote{remote\_data}} propertyju. Uz to, moguce je raditi i
obicno slanje poruka kroz \sphinxcode{\sphinxupquote{send}} i \sphinxcode{\sphinxupquote{receive}} metode, definirati RPC sucelja
itd. Prakticno, u radu s jugglerom, odnosno \sphinxcode{\sphinxupquote{AdapterSessionClient}}\sphinxhyphen{}om,
najvise cemo se oslanjati na sinkronizaciju stanja i slanje poruka.

\sphinxAtStartPar
Sad imamo dovoljno informacija da napravimo jednostavnu implementaciju
adaptera. Nastavljamo s nasim primjerom ranijeg zadatka s ampermetrima. Ako se
sjecamo, napravili smo modul event servera koji registrira dogadaj tipa
\sphinxcode{\sphinxupquote{(\textquotesingle{}state\textquotesingle{})}} ciji payload je dictionary gdje su kljucevi imena struja, a
vrijednosti njihovi iznosi. Sad mozemo napraviti adapter koji ce to stanje
propagirati do klijenata:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{aio}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{gui}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{util}


\PYG{n}{json\PYGZus{}schema\PYGZus{}id} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{json\PYGZus{}schema\PYGZus{}repo} \PYG{o}{=} \PYG{k+kc}{None}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}subscription}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Subscription}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{)}\PYG{p}{]}\PYG{p}{)}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}adapter}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{,} \PYG{n}{event\PYGZus{}client}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{adapter} \PYG{o}{=} \PYG{n}{StateAdapter}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{aio}\PYG{o}{.}\PYG{n}{Group}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}client} \PYG{o}{=} \PYG{n}{event\PYGZus{}client}
    \PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}\PYG{o}{.}\PYG{n}{spawn}\PYG{p}{(}\PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}main\PYGZus{}loop}\PYG{p}{)}
    \PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}sessions} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{adapter}


\PYG{k}{class} \PYG{n+nc}{StateAdapter}\PYG{p}{(}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{gui}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Adapter}\PYG{p}{)}\PYG{p}{:}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}group}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}session}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{juggler\PYGZus{}client}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{session} \PYG{o}{=} \PYG{n}{StateAdapterSession}\PYG{p}{(}
            \PYG{n}{juggler\PYGZus{}client}\PYG{p}{,}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}\PYG{o}{.}\PYG{n}{create\PYGZus{}subgroup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}sessions}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{session}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{session}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{\PYGZus{}main\PYGZus{}loop}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
            \PYG{n}{events} \PYG{o}{=} \PYG{k}{await} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}client}\PYG{o}{.}\PYG{n}{receive}\PYG{p}{(}\PYG{p}{)}
            \PYG{k}{for} \PYG{n}{event} \PYG{o+ow}{in} \PYG{n}{events}\PYG{p}{:}
                \PYG{n}{state} \PYG{o}{=} \PYG{n}{event}\PYG{o}{.}\PYG{n}{payload}\PYG{o}{.}\PYG{n}{data}
                \PYG{k}{for} \PYG{n}{session} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}sessions}\PYG{p}{:}
                    \PYG{k}{if} \PYG{n}{session}\PYG{o}{.}\PYG{n}{is\PYGZus{}open}\PYG{p}{:}
                        \PYG{n}{session}\PYG{o}{.}\PYG{n}{notify\PYGZus{}state\PYGZus{}change}\PYG{p}{(}\PYG{n}{state}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{StateAdapterSession}\PYG{p}{(}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{gui}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{AdapterSession}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{juggler\PYGZus{}client}\PYG{p}{,} \PYG{n}{group}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}juggler\PYGZus{}client} \PYG{o}{=} \PYG{n}{juggler\PYGZus{}client}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group} \PYG{o}{=} \PYG{n}{group}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}group}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}

    \PYG{k}{def} \PYG{n+nf}{notify\PYGZus{}state\PYGZus{}change}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{state}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}juggler\PYGZus{}client}\PYG{o}{.}\PYG{n}{set\PYGZus{}local\PYGZus{}data}\PYG{p}{(}\PYG{n}{state}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Ako ima nejasnoca vezanih uz poziv \sphinxcode{\sphinxupquote{spawn}} metode, logika je ista kao i kod
devicea, pa predlazemo da pogledate taj dio. Dakle, adapter u \sphinxcode{\sphinxupquote{\_main\_loop}}
ceka promjene stanja i kad primi dogadaj, proslijedi tu informaciju sesijama.
Sesije onda dalje tu informaciju proslijede web klijentima.

\sphinxAtStartPar
Sad mozemo pokrenuti \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}gui}} s ovim adapterom, no jos uvijek nam fale
viewovi. Kako smo spomenuli da je njihov razvoj odvojena tema za sebe, zasad
cemo koristiti prethodno buildane resurse. Njima, i svim ostalim
implementacijama koje smo radili u ovom poglavlju, mozete pristupiti na \sphinxhref{https://github.com/rppiot2021/materials/tree/master/hat/components}{ovom
linku}
Pokretanjem svega (\sphinxcode{\sphinxupquote{hat\sphinxhyphen{}event}}, \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}gateway}} i \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}gui}}) i otvaranjem
adrese \sphinxhref{http://127.0.0.1:23023}{127.0.0.1:23023} trebala bi se otvoriti prvo
login stranica (user1, pass1), a nakon logina prikaz u kojem se vidi JSON
reprezentacija stanja koje smo propagirali kroz dogadaje. Iduce vece poglavlje
bavit ce se osnovama razvoja grafickog sucelja u bibliotekama iz hat\sphinxhyphen{}open
projekta.


\chapter{Modbus hat aplikacija}
\label{\detokenize{03-hat-modbus-workshop/index:modbus-hat-aplikacija}}\label{\detokenize{03-hat-modbus-workshop/index::doc}}
\sphinxAtStartPar
U proslom zadatku vidjeli smo kako se spojiti Modbus protokolom na termometar
kroz jednostavnu Pyhton skriptu. U ovom dijelu implementiramo slicnu stvar,
koristenjem komponenti iz hat\sphinxhyphen{}open projekta. Poglavlje o Hatu temeljito opisuje
pojedine komponente a ovdje cemo ih primjeniti za rjesavanje problema s
termometrom.


\section{Repozitorij}
\label{\detokenize{03-hat-modbus-workshop/index:repozitorij}}
\sphinxAtStartPar
Krecemo s repozitorijem \sphinxhref{https://github.com/rppiot2021/hat-quickstart}{hat\sphinxhyphen{}quickstart}. Ovo je template repozitorij
na temelju kojeg se mogu kreirati novi repozitoriji (\sphinxtitleref{Use this template} gumb).
U repozitoriju su napisane upute kako postaviti razvojno okruzenje. Ono bi
trebalo raditi na Linuxu, kod ostalih operacijskih sustava mozda naidete na
probleme i u tom slucaju preporucujemo rad ili kroz virtualnu masinu ili kroz
docker.

\sphinxAtStartPar
Repozitorij ima par bitnih direktorija. Prvi su \sphinxcode{\sphinxupquote{src\_py}} i \sphinxcode{\sphinxupquote{src\_js}}, u
kojima ce se nalaziti implementacija nase aplikacije. Python dio implementacije
fokusirat ce se na ocitanje i obradu podataka, a JavaScript na vizualizaciju
kroz web sucelje. U \sphinxcode{\sphinxupquote{playground}} direktoriju imamo razlicite pomocne skripte
i konfiguracije pomocu kojih se sustav moze pokretati. Ostale datateke i
direktoriji se takoder koriste, ali na ove cemo se uglavnom fokusirati tijekom
rada na ovom zadatku. Pozicioniranjem u direktorij \sphinxcode{\sphinxupquote{playground/run}} mozemo
pokrenti skriptu \sphinxcode{\sphinxupquote{system.sh}} (ili \sphinxcode{\sphinxupquote{.bat}} za Windowse), otvoriti
\sphinxcode{\sphinxupquote{localhost:23023}} i vidjeti minimalno graficko sucelje s jednim brojacem.

\sphinxAtStartPar
Bacimo li dublji pogled na to sto se tocno dogada pozivom \sphinxcode{\sphinxupquote{system}} skripte,
vidimo da ona pokrece \sphinxcode{\sphinxupquote{hat\sphinxhyphen{}orchestrator}} komponentu. Ova komponenta sluzi
tome da paralelno starta proizvoljni broj drugih procesa. Pogledamo li njenu
konfiguraciju, u \sphinxcode{\sphinxupquote{playground/run/data/orchestrator.yaml}}, vidimo u
\sphinxcode{\sphinxupquote{components}} polju koji procesi se sve pokrecu. Vidimo da su to druge
komponente iz hat\sphinxhyphen{}open projekta (pogledajte predavanje 3.1. za kratki pregled
komponenti koje postoje i neke njihove generalne svrhe). Za rjesenje problema,
implementirati cemo jedan device, event server modul i adapter. Takoder cemo
prilagoditi view da ima tocniji ispis, tj. da ne pise \sphinxtitleref{counter} vec
temperature.


\section{Rjesenje}
\label{\detokenize{03-hat-modbus-workshop/index:rjesenje}}
\sphinxAtStartPar
Ovdje opisujemo pristup koji uzimamo kad rjesavamo problem, komponentu po
komponentu. Krecemo od devicea koji ce nam komunicirati s modbus uredajem,
nakon toga implementiramo event server modul, koji ce obavljati izracun
temperature (djeljenje s 10 jer protokol salje vrijednost pomnozenu s 10), iza
toga adapter koji ce pripremati te podatke za vizualizaciju, i konacno view
kojeg cemo prilagoditi da prikazuje podatke. U quickstart repozitoriju vec
postoje primjeri za svaki od ovih tipova specijaliziranih modula, tako da cemo
se donekle oslanjati samo na njihovu modifikaciju.


\subsection{Device}
\label{\detokenize{03-hat-modbus-workshop/index:device}}
\noindent\sphinxincludegraphics{{hat-arch-gateway1}.png}

\sphinxAtStartPar
Zelimo implementirati device koji ce svakih nekoliko sekundi slati Modbus
zahtjev za citanje na termometar i registrirati dogadaj s informacijom koja je
primljena preko protokola. Slicnu funkcionalnost smo vec implementirali u
drugom zadatku, samo sad ju trebamo upakirati u implementaciju devicea i
umjesto ispisa na konzolu, registrirati dogadaj. Implementacija uredaja u
\sphinxcode{\sphinxupquote{src\_py/project/devices/example.py}} je u principu dovoljno dobra, glavna
modifikacija koju trebamo napraviti je prilagodba countera. \sphinxtitleref{Example} verzija
uredaja se ne spaja na nista nego samo ima jedan interni brojac kojeg
inkrementira svakih nekoliko sekundi. Umjesto toga, mi se zelimo spojiti na
termometar i svakih nekoliko sekundi registrirati ocitanje s njega. Takoder,
putanja \sphinxcode{\sphinxupquote{project/devices/example}} je malo nejasna, tako da cemo ju
preimenovati u nesto sto ima smisla za nas projekt:
\sphinxcode{\sphinxupquote{workshop/devices/modbus}}.

\sphinxAtStartPar
Primjetimo da sad vise ne mozemo pozvati sustav kroz \sphinxcode{\sphinxupquote{system.sh/bat}}. Razlog
tome je upravo ova promjena putanje, device koji konfiguriramo u gatewayu ima
staro Python ime, pa cemo ga prilagoditi u \sphinxcode{\sphinxupquote{module: workshop.devices.modbus}}
(u \sphinxcode{\sphinxupquote{playground/run/data/gateway.yaml}}). Uz to, dodatno cemo prilagoditi
konfiguraciju tako da damo konkretnija imena deviceu i gatewayu: \sphinxcode{\sphinxupquote{modbus1}} i
\sphinxcode{\sphinxupquote{gateway1}}.

\sphinxAtStartPar
Device sad izgleda ovako:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{asyncio}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{aio}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{gateway}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{from} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{drivers} \PYG{k+kn}{import} \PYG{n}{modbus}\PYG{p}{,} \PYG{n}{tcp}


\PYG{n}{json\PYGZus{}schema\PYGZus{}id} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{json\PYGZus{}schema\PYGZus{}repo} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{device\PYGZus{}type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{modbus}\PYG{l+s+s1}{\PYGZsq{}}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{,} \PYG{n}{event\PYGZus{}client}\PYG{p}{,} \PYG{n}{event\PYGZus{}type\PYGZus{}prefix}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{device} \PYG{o}{=} \PYG{n}{ModbusDevice}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{device}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{aio}\PYG{o}{.}\PYG{n}{Group}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{device}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}client} \PYG{o}{=} \PYG{n}{event\PYGZus{}client}
    \PYG{n}{device}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}type\PYGZus{}prefix} \PYG{o}{=} \PYG{n}{event\PYGZus{}type\PYGZus{}prefix}
    \PYG{n}{device}\PYG{o}{.}\PYG{n}{\PYGZus{}task} \PYG{o}{=} \PYG{n}{asyncio}\PYG{o}{.}\PYG{n}{create\PYGZus{}task}\PYG{p}{(}\PYG{n}{device}\PYG{o}{.}\PYG{n}{\PYGZus{}main\PYGZus{}loop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{device}


\PYG{k}{class} \PYG{n+nc}{ModbusDevice}\PYG{p}{(}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{gateway}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Device}\PYG{p}{)}\PYG{p}{:}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}group}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{\PYGZus{}main\PYGZus{}loop}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{modbus\PYGZus{}type} \PYG{o}{=} \PYG{n}{modbus}\PYG{o}{.}\PYG{n}{ModbusType}\PYG{o}{.}\PYG{n}{TCP}
        \PYG{n}{address} \PYG{o}{=} \PYG{n}{tcp}\PYG{o}{.}\PYG{n}{Address}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{161.53.17.239}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{8502}\PYG{p}{)}
        \PYG{n}{master} \PYG{o}{=} \PYG{k}{await} \PYG{n}{modbus}\PYG{o}{.}\PYG{n}{create\PYGZus{}tcp\PYGZus{}master}\PYG{p}{(}\PYG{n}{modbus\PYGZus{}type}\PYG{p}{,} \PYG{n}{address}\PYG{p}{)}
        \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
            \PYG{n}{data} \PYG{o}{=} \PYG{k}{await} \PYG{n}{master}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}
                \PYG{n}{device\PYGZus{}id}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}
                \PYG{n}{data\PYGZus{}type}\PYG{o}{=}\PYG{n}{modbus}\PYG{o}{.}\PYG{n}{DataType}\PYG{o}{.}\PYG{n}{HOLDING\PYGZus{}REGISTER}\PYG{p}{,}
                \PYG{n}{start\PYGZus{}address}\PYG{o}{=}\PYG{l+m+mi}{4003}\PYG{p}{,} \PYG{n}{quantity}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}client}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{p}{[}
                \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{RegisterEvent}\PYG{p}{(}
                    \PYG{n}{event\PYGZus{}type}\PYG{o}{=}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}type\PYGZus{}prefix}\PYG{p}{,}
                                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gateway}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4003}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
                    \PYG{n}{source\PYGZus{}timestamp}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
                    \PYG{n}{payload}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayload}\PYG{p}{(}
                        \PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayloadType}\PYG{o}{.}\PYG{n}{JSON}\PYG{p}{,}
                        \PYG{n}{data}\PYG{o}{=}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Trebalo bi se moci pokrenuti, no sad smo uveli promjene zbog kojih osnovni
quickstart primjer nece moci samostalno raditi. Ali, to ce se promijeniti kad
prilagodimo ostale komponente.


\subsection{Modul}
\label{\detokenize{03-hat-modbus-workshop/index:modul}}
\noindent\sphinxincludegraphics{{hat-arch-event1}.png}

\sphinxAtStartPar
Sad se prebacujemo na event server module. Ako pogledamo koji moduli postoje,
vidjet cemo direktorij \sphinxcode{\sphinxupquote{src\_py/project/modules}} s modulima \sphinxcode{\sphinxupquote{example.py}} i
\sphinxcode{\sphinxupquote{enable\_all.py}}. \sphinxcode{\sphinxupquote{enable\_all}} mozemo ignorirati, njegova svrha je da
registrira dogadaje za paljenje deviceova (vise info u poglavlju o Hatu).

\sphinxAtStartPar
Odmah cemo oba modula prebaciti u \sphinxcode{\sphinxupquote{workshop/modules}}, a \sphinxcode{\sphinxupquote{example}} cemo
preimenovati u \sphinxcode{\sphinxupquote{temperature}} jer cemo ga preinaciti u to da racuna
temperaturu na temelju dogadaja koje registrira device.

\sphinxAtStartPar
Znamo da device registrira ocitanja temperatura u dogadajima s tipom
\sphinxcode{\sphinxupquote{(\textquotesingle{}gateway\textquotesingle{}, \textquotesingle{}gateway1\textquotesingle{}, \textquotesingle{}modbus\textquotesingle{}, \textquotesingle{}modbus1\textquotesingle{}, \textquotesingle{}gateway\textquotesingle{}, \textquotesingle{}4003\textquotesingle{})}}, tako da
cemo pretplatiti modul na taj tip. Nakon toga, nema neke potrebe za vecim
preinakama, osim prilagodbe \sphinxcode{\sphinxupquote{process}} metode u sesiji od modula. Ona ce sad
registrirati dogadaj s tipom \sphinxcode{\sphinxupquote{(\textquotesingle{}temperature\textquotesingle{})}} a payload ce joj biti tocna
temperatura, iznos koji primi preko Modbusa podijeljen s 10.

\sphinxAtStartPar
Implementacija modula izgleda ovako:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{aio}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{server}\PYG{n+nn}{.}\PYG{n+nn}{common}


\PYG{n}{json\PYGZus{}schema\PYGZus{}id} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{json\PYGZus{}schema\PYGZus{}repo} \PYG{o}{=} \PYG{k+kc}{None}

\PYG{n}{\PYGZus{}source\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{,} \PYG{n}{engine}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{module} \PYG{o}{=} \PYG{n}{TemperatureModule}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{global} \PYG{n}{\PYGZus{}source\PYGZus{}id}
    \PYG{n}{module}\PYG{o}{.}\PYG{n}{\PYGZus{}source} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Source}\PYG{p}{(}
        \PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{SourceType}\PYG{o}{.}\PYG{n}{MODULE}\PYG{p}{,}
        \PYG{n}{name}\PYG{o}{=}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{,}
        \PYG{n+nb}{id}\PYG{o}{=}\PYG{n}{\PYGZus{}source\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{\PYGZus{}source\PYGZus{}id} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{n}{module}\PYG{o}{.}\PYG{n}{\PYGZus{}subscription} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Subscription}\PYG{p}{(}\PYG{p}{[}
        \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gateway}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{?}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{modbus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{?}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gateway}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4003}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{module}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{aio}\PYG{o}{.}\PYG{n}{Group}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{module}\PYG{o}{.}\PYG{n}{\PYGZus{}engine} \PYG{o}{=} \PYG{n}{engine}

    \PYG{k}{return} \PYG{n}{module}


\PYG{k}{class} \PYG{n+nc}{TemperatureModule}\PYG{p}{(}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Module}\PYG{p}{)}\PYG{p}{:}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}group}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{subscription}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}subscription}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}session}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{TemperatureModuleSession}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}engine}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}source}\PYG{p}{,}
                                        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}\PYG{o}{.}\PYG{n}{create\PYGZus{}subgroup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{TemperatureModuleSession}\PYG{p}{(}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{ModuleSession}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{engine}\PYG{p}{,} \PYG{n}{source}\PYG{p}{,} \PYG{n}{group}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}engine} \PYG{o}{=} \PYG{n}{engine}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}source} \PYG{o}{=} \PYG{n}{source}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group} \PYG{o}{=} \PYG{n}{group}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}group}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{process}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{changes}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}engine}\PYG{o}{.}\PYG{n}{create\PYGZus{}process\PYGZus{}event}\PYG{p}{(}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}source}\PYG{p}{,}
                \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{server}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{RegisterEvent}\PYG{p}{(}
                    \PYG{n}{event\PYGZus{}type}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{temperature}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{)}\PYG{p}{,}
                    \PYG{n}{source\PYGZus{}timestamp}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
                    \PYG{n}{payload}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayload}\PYG{p}{(}
                        \PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{EventPayloadType}\PYG{o}{.}\PYG{n}{JSON}\PYG{p}{,}
                        \PYG{n}{data}\PYG{o}{=}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{event}\PYG{o}{.}\PYG{n}{payload}\PYG{o}{.}\PYG{n}{data} \PYG{o}{/} \PYG{l+m+mi}{10}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{k}{for} \PYG{n}{event} \PYG{o+ow}{in} \PYG{n}{changes}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Ne zaboravimo da je i dalje potrebno uvesti promjene u konfiguraciju, analogne
promjenama u gatewayu, dakle imena modula.


\subsection{Adapter}
\label{\detokenize{03-hat-modbus-workshop/index:adapter}}
\noindent\sphinxincludegraphics{{hat-arch-gui1}.png}

\sphinxAtStartPar
Konacno se fokusiramo na vizualizaciju. Prvi korak je implementacija adaptera
koji bi preko svog sucelja za komunikaciju s web klijentima posluzivao stanje
u kojem je ocitanje temperature. On bi se pretplacivao na \sphinxcode{\sphinxupquote{(\textquotesingle{}temperature\textquotesingle{})}}
dogadaj koji registriramo u event serverovom modulu.

\sphinxAtStartPar
Ako pogledamo adaptere iz quickstarta, vidimo da postoji
\sphinxcode{\sphinxupquote{src\_py/project/adapters/example.py}}. Njega cemo prilagoditi da ne radi vise
s brojacem, vec da se pretplacuje na promjene temperature i prosljeduje ih
svojim sesijama. To postizemo implementacijom \sphinxcode{\sphinxupquote{create\_subscription}} funkcije.
Drugi korak je proslijedivanje temperature sesijama, sto se dogadalo u
\sphinxcode{\sphinxupquote{\_main\_loop}} metodi. Ona zapravo moze biti ista, ali malo cemo prilagoditi
imena varijabli, nema potrebe da se temperatura pohranjuje u privatnim
varijablama adapterove klase itd. Tako dolazimo do sljedece implementacije:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{aio}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{event}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{gui}\PYG{n+nn}{.}\PYG{n+nn}{common}
\PYG{k+kn}{import} \PYG{n+nn}{hat}\PYG{n+nn}{.}\PYG{n+nn}{util}


\PYG{n}{json\PYGZus{}schema\PYGZus{}id} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{json\PYGZus{}schema\PYGZus{}repo} \PYG{o}{=} \PYG{k+kc}{None}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}subscription}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{event}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Subscription}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{temperature}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{)}\PYG{p}{]}\PYG{p}{)}


\PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}adapter}\PYG{p}{(}\PYG{n}{conf}\PYG{p}{,} \PYG{n}{event\PYGZus{}client}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{adapter} \PYG{o}{=} \PYG{n}{TemperatureAdapter}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{aio}\PYG{o}{.}\PYG{n}{Group}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}client} \PYG{o}{=} \PYG{n}{event\PYGZus{}client}
    \PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}state\PYGZus{}change\PYGZus{}cb\PYGZus{}registry} \PYG{o}{=} \PYG{n}{hat}\PYG{o}{.}\PYG{n}{util}\PYG{o}{.}\PYG{n}{CallbackRegistry}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}sessions} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}\PYG{o}{.}\PYG{n}{spawn}\PYG{p}{(}\PYG{n}{adapter}\PYG{o}{.}\PYG{n}{\PYGZus{}main\PYGZus{}loop}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{adapter}


\PYG{k}{class} \PYG{n+nc}{TemperatureAdapter}\PYG{p}{(}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{gui}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{Adapter}\PYG{p}{)}\PYG{p}{:}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}group}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}session}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{juggler\PYGZus{}client}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{session} \PYG{o}{=} \PYG{n}{TemperatureAdapterSession}\PYG{p}{(}
            \PYG{n}{juggler\PYGZus{}client}\PYG{p}{,}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}\PYG{o}{.}\PYG{n}{create\PYGZus{}subgroup}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}sessions}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{session}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{session}

    \PYG{k}{async} \PYG{k}{def} \PYG{n+nf}{\PYGZus{}main\PYGZus{}loop}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
            \PYG{n}{events} \PYG{o}{=} \PYG{k}{await} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}event\PYGZus{}client}\PYG{o}{.}\PYG{n}{receive}\PYG{p}{(}\PYG{p}{)}
            \PYG{k}{for} \PYG{n}{event} \PYG{o+ow}{in} \PYG{n}{events}\PYG{p}{:}
                \PYG{n}{temperature} \PYG{o}{=} \PYG{n}{event}\PYG{o}{.}\PYG{n}{payload}\PYG{o}{.}\PYG{n}{data}
            \PYG{k}{for} \PYG{n}{session} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}sessions}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{session}\PYG{o}{.}\PYG{n}{is\PYGZus{}open}\PYG{p}{:}
                    \PYG{n}{session}\PYG{o}{.}\PYG{n}{notify\PYGZus{}state\PYGZus{}change}\PYG{p}{(}\PYG{n}{temperature}\PYG{p}{)}


\PYG{k}{class} \PYG{n+nc}{TemperatureAdapterSession}\PYG{p}{(}\PYG{n}{hat}\PYG{o}{.}\PYG{n}{gui}\PYG{o}{.}\PYG{n}{common}\PYG{o}{.}\PYG{n}{AdapterSession}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{juggler\PYGZus{}client}\PYG{p}{,} \PYG{n}{group}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}juggler\PYGZus{}client} \PYG{o}{=} \PYG{n}{juggler\PYGZus{}client}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group} \PYG{o}{=} \PYG{n}{group}

    \PYG{n+nd}{@property}
    \PYG{k}{def} \PYG{n+nf}{async\PYGZus{}group}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}async\PYGZus{}group}

    \PYG{k}{def} \PYG{n+nf}{notify\PYGZus{}state\PYGZus{}change}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{state}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}juggler\PYGZus{}client}\PYG{o}{.}\PYG{n}{set\PYGZus{}local\PYGZus{}data}\PYG{p}{(}\PYG{n}{state}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Opet cemo promijeniti putanju adapteru tako da ga prebacimo u
\sphinxcode{\sphinxupquote{workshop/adapter}} i preimenujemo u \sphinxcode{\sphinxupquote{temperature.py}} (nema veze sto je isto
kao i modul, sama cinjenica da su u drugim direktorijima je dovoljna
distinkcija), pa je potrebno prilagoditi i konfiguraciju. Osim promjene
putanje, prilagoditi cemo i ime adaptera iz \sphinxcode{\sphinxupquote{adapter}} u \sphinxcode{\sphinxupquote{temperature}}.


\subsection{View}
\label{\detokenize{03-hat-modbus-workshop/index:view}}
\sphinxAtStartPar
Da bi prilagodba bila kompletna, potrebno je prilagoditi i view. Dosad nismo
toliko zalazili u detalje kako se view implementira, ali nam za pocetak oni
nisu ni previse bitni. Implementacija viewa je u
\sphinxcode{\sphinxupquote{src\_js/views/main/index.js}}. Vidimo da vec postoji neka implementacija koja
ima funkciju \sphinxcode{\sphinxupquote{vt}} koja vraca listu. Lista sadrzi ime taga i njegov sadrzaj.
Za graficke prikaze koristimo bibilioteke koje ovakve strukture podataka
pretvaraju u DOM (Document Object Model). Tako kad implementiramo view, ono sto
vrati njegova funkcija proslijeduje se tim bibliotekama i one generiraju DOM s
elementima:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{span}\PYG{o}{\PYGZgt{}}\PYG{n}{counter}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{span}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Ocita je jos jedna promjena \sphinxhyphen{} izraz \sphinxcode{\sphinxupquote{r.get(\textquotesingle{}remote\textquotesingle{}, \textquotesingle{}adapter\textquotesingle{}, \textquotesingle{}counter\textquotesingle{})}}
se pretvoro u broj 10. U viewovima preko varijable \sphinxcode{\sphinxupquote{r}} pristupamo \sphinxhref{https://hat-renderer.hat-open.com/}{renderer
objektu} (dokumentacija je nekompletna,
bolje mozda gledati kod). Cijela ideja iza renderera je da on ima neko svoje
stanje i na temelju tog stanja generira DOM. Kad se stanje promijeni, ponovno
se pokrene izracun DOM\sphinxhyphen{}a na temelju tog novog stanja. Stanju pristupamo preko
funkcije \sphinxcode{\sphinxupquote{r.get}}, a mozemo ga mijenjati preko funkcije \sphinxcode{\sphinxupquote{r.set}}. Tako kad
kazemo \sphinxcode{\sphinxupquote{counter: r.get(\textquotesingle{}remote\textquotesingle{}, \textquotesingle{}adapter\textquotesingle{}, \textquotesingle{}counter\textquotesingle{})}}, zapravo oznacavamo
da iza dvotocke pise vrijednost procitana iz stanja aplikacije. Argumentima
poslanim \sphinxcode{\sphinxupquote{r.get}} funkciji odredujemo putanju do dijela stanja koji nas
zanima. Konkretno u ovom slucaju, brojacu pristupamo s putanjom
\sphinxcode{\sphinxupquote{remote/adapter/counter}} jer je stanje objekt:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{n}{remote}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n}{adapter}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n}{counter}\PYG{p}{:} \PYG{l+m+mi}{10} \PYG{p}{\PYGZcb{}} \PYG{p}{\PYGZcb{}} \PYG{p}{,} \PYG{n}{local}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{xyz}\PYG{p}{:} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Kod viewova postoji dodatni aspekt rada sa stanjem, a to je cinjenica da je
nasa aplikacija spojena na GUI server. GUI server notificira promjene stanja
svojim klijentima. To znaci da se u nekom trenutku implicitno poziva \sphinxcode{\sphinxupquote{r.set}}
kad neki adapter prijavi da mu se stanje promijenilo. Konkretno, dio stanja na
koji utjece adapter nalazi se na putanji \sphinxcode{\sphinxupquote{remote/\textless{}ime\_adaptera\textgreater{}}}.

\sphinxAtStartPar
Vracajuci se na radionicu, dosadasnji view s brojacem nam vise ne odgovara,
htjeli bismo da umjesto counter pise temperature. Dodatno, mijenjali smo ime i
strukturu stanja adaptera, pa vise ni \sphinxcode{\sphinxupquote{r.get}} nije precizan. Ako zelimo
promijeniti tekst, prevodimo \sphinxcode{\sphinxupquote{counter:}} u \sphinxcode{\sphinxupquote{temperature:}}, a nova putanja je
\sphinxcode{\sphinxupquote{remote/temperature}} (\sphinxcode{\sphinxupquote{temperature}} je ime adaptera, a njegovo stanje je
samo jedan broj).

\sphinxAtStartPar
Ta implementacija sad bi trebala izgledati ovako:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{import} \PYG{l+s+s1}{\PYGZsq{}main/index.scss\PYGZsq{}}\PYG{p}{;}


\PYG{k}{export} \PYG{k+kd}{function} \PYG{n+nx}{vt}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}span\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sb}{`}\PYG{l+s+sb}{temperature: }\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nx}{r}\PYG{p}{.}\PYG{n+nx}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}remote\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}temperature\PYGZsq{}}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+sb}{`}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nakon buildanja viewa (\sphinxcode{\sphinxupquote{doit js\_view}}), mozemo otvoriti browser na adresu
\sphinxcode{\sphinxupquote{http://127.0.0.1:23023}} i vidjeti nas novi termometar.



\renewcommand{\indexname}{Abecedni popis}
\printindex
\end{document}